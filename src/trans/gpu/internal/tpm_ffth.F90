! (C) Copyright 2014- ECMWF.
! 
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.
!

MODULE TPM_FFTH

  !   Author.
  !   -------
  !     George Mozdzynski
  !
  !   Modifications.
  !   -------------- 
  !     Original      October 2014
  
  USE, INTRINSIC :: ISO_C_BINDING
  
  USE PARKIND_ECTRANS ,ONLY : JPIM, JPRBT
  !USE MPL_MODULE      ,ONLY : MPL_MYRANK
  
  IMPLICIT NONE
  
  SAVE
  
  PRIVATE
  PUBLIC CREATE_PLAN_FFT, DESTROY_PLAN_FFT, DESTROY_ALL_PLANS_FFT, INIT_PLANS_FFT, EXECUTE_PLAN_FFT, &
        & FFTH_RESOL, TC
  
  TYPE FFTH_TYPE
    INTEGER(KIND=C_INT),POINTER :: N_PLANS(:)
    TYPE(FFTH_PLAN),POINTER :: FFTH_PLANS(:)
    INTEGER(KIND=C_INT) :: N_MAX=0
  END TYPE FFTH_TYPE
  
  
  TYPE FFTH_PLAN
    TYPE(C_PTR) :: NPLAN
    INTEGER(KIND=C_INT) :: NLOT
    INTEGER(KIND=C_INT) :: NTYPE
    TYPE(FFTH_PLAN),POINTER :: NEXT_PLAN => NULL()
  END TYPE FFTH_PLAN
  
  TYPE(FFTH_TYPE),ALLOCATABLE,TARGET :: FFTH_RESOL(:)
  TYPE(FFTH_TYPE),POINTER     :: TC
  
  
  
  ! ------------------------------------------------------------------
  CONTAINS
  ! ------------------------------------------------------------------
  
  
  SUBROUTINE INIT_PLANS_FFT(KDLON)
  INTEGER(KIND=C_INT),INTENT(IN) :: KDLON
  
  TC%N_MAX=KDLON
  ALLOCATE(TC%FFTH_PLANS(TC%N_MAX))
  ALLOCATE(TC%N_PLANS(TC%N_MAX))
  TC%N_PLANS(:)=0
  RETURN  
  END SUBROUTINE INIT_PLANS_FFT
  
  
  SUBROUTINE CREATE_PLAN_FFT(KPLAN,KTYPE,KN,KLOT)
  TYPE(C_PTR),INTENT(OUT) :: KPLAN
  INTEGER(KIND=C_INT),INTENT(IN) :: KTYPE,KN,KLOT
  
  TYPE(C_PTR) :: IPLAN
  INTEGER(KIND=C_INT) :: IRANK, ISTRIDE
  INTEGER(KIND=C_INT) :: JL, JN
  INTEGER(KIND=C_INT) :: IRDIST,ICDIST,IN(1),IEMBED(1)
  LOGICAL :: LLFOUND
  TYPE(FFTH_PLAN),POINTER :: CURR_FFTH_PLAN,START_FFTH_PLAN
  
  INTERFACE
    SUBROUTINE CREATE_PLAN_FFTH(KPLAN,KTYPE,KN,KLOT) BIND(C,NAME="create_plan_ffth_")
     USE, INTRINSIC :: ISO_C_BINDING
     TYPE(C_PTR), INTENT(OUT) :: KPLAN
     INTEGER(C_INT), INTENT(IN) :: KTYPE,KN,KLOT
    END SUBROUTINE CREATE_PLAN_FFTH
  END INTERFACE
  
  IF( KN > TC%N_MAX )THEN
    stop 'CREATE_PLAN_FFT: KN > N_MAX THAT WAS INITIALISED IN INIT_PLANS_FFTH'
  ENDIF
  
  IRANK=1
  ISTRIDE=1
  IN(1)=KN
  IEMBED(1)=IN(1)
  ICDIST=KN/2+1
  IRDIST=ICDIST*2
  
  !!$OMP CRITICAL
  LLFOUND=.FALSE.
  CURR_FFTH_PLAN=>TC%FFTH_PLANS(KN)
  ! search for plan in existing plans
  DO JL=1,TC%N_PLANS(KN)
    IF( KLOT == CURR_FFTH_PLAN%NLOT .AND. KTYPE == CURR_FFTH_PLAN%NTYPE )THEN
      LLFOUND=.TRUE.
      IPLAN=CURR_FFTH_PLAN%NPLAN
      EXIT
    ELSEIF( JL /= TC%N_PLANS(KN) )THEN
      CURR_FFTH_PLAN=>CURR_FFTH_PLAN%NEXT_PLAN
    ENDIF
  ENDDO
  IF( .NOT.LLFOUND )THEN
    CALL CREATE_PLAN_FFTH(IPLAN,KTYPE,KN,KLOT)
    KPLAN=IPLAN
    TC%N_PLANS(KN)=TC%N_PLANS(KN)+1
    IF( TC%N_PLANS(KN) /= 1 )THEN
      ALLOCATE(CURR_FFTH_PLAN%NEXT_PLAN)
      CURR_FFTH_PLAN=>CURR_FFTH_PLAN%NEXT_PLAN
    ENDIF
    CURR_FFTH_PLAN%NPLAN=IPLAN
    CURR_FFTH_PLAN%NLOT=KLOT
    CURR_FFTH_PLAN%NTYPE=KTYPE
    CURR_FFTH_PLAN%NEXT_PLAN=>NULL()
  ! write(*,'("CREATE_PLAN_FFT: KN=",I5," NPLANS=",I3," KLOT=",I6," KTYPE=",I2,&
  !  & " NEW IPLAN=",Z16)')KN,TC%N_PLANS(KN),KLOT,KTYPE,IPLAN
  ELSE
    KPLAN=IPLAN
  ! write(*,'("CREATE_PLAN_FFT: KN=",I5," NPLANS=",I3," KLOT=",I6," KTYPE=",I2,&
  !  & " CUR IPLAN=",Z16)')KN,TC%N_PLANS(KN),KLOT,KTYPE,IPLAN
  ENDIF
  !!$OMP END CRITICAL
  
  RETURN
  END SUBROUTINE CREATE_PLAN_FFT
  
  
  SUBROUTINE DESTROY_PLAN_FFT(KPLAN)
  TYPE(C_PTR),INTENT(IN) :: KPLAN

  INTERFACE
    SUBROUTINE DESTROY_PLAN_FFTH(KPLAN) BIND(C, NAME="destroy_plan_ffth_")
        USE, INTRINSIC :: ISO_C_BINDING
        TYPE(C_PTR), VALUE, INTENT(IN) :: KPLAN
    END SUBROUTINE DESTROY_PLAN_FFTH
  END INTERFACE

  CALL DESTROY_PLAN_FFTH(KPLAN)

  END SUBROUTINE DESTROY_PLAN_FFT
  
  
  SUBROUTINE DESTROY_ALL_PLANS_FFT
    IMPLICIT NONE

    INTEGER(KIND=C_INT) :: JL, JN
    TYPE(FFTH_PLAN), POINTER :: CURR_FFTH_PLAN

    IF( .NOT. ASSOCIATED(TC) ) THEN
      RETURN
    ENDIF

    IF ( .NOT. ASSOCIATED(TC%FFTH_PLANS) .OR. .NOT. ASSOCIATED(TC%N_PLANS) ) THEN
      RETURN
    ENDIF

    DO JN = 1, TC%N_MAX
       CURR_FFTH_PLAN=>TC%FFTH_PLANS(JN)
       DO JL = 1, TC%N_PLANS(JN)
         IF( ASSOCIATED(CURR_FFTH_PLAN) ) THEN
           CALL DESTROY_PLAN_FFT(CURR_FFTH_PLAN%NPLAN)
           CURR_FFTH_PLAN=>CURR_FFTH_PLAN%NEXT_PLAN
         ENDIF
       ENDDO
    ENDDO
    !WRITE(*,'("DESTROY_ALL_PLANS_FFTH: MPL_RANK=",I6," SUM(TC%N_PLANS(:))=",I10)')&
    !  & MPL_MYRANK(), SUM(TC%N_PLANS(:))
    DEALLOCATE(TC%FFTH_PLANS)
    DEALLOCATE(TC%N_PLANS)

  END SUBROUTINE DESTROY_ALL_PLANS_FFT
  
  SUBROUTINE EXECUTE_PLAN_FFT(KN,N,X_IN,X_OUT,PLAN_PTR)
  TYPE(C_PTR) :: PLAN_PTR
  INTEGER(KIND=C_INT) :: KN
  INTEGER(KIND=C_INT) :: N
  REAL(KIND=JPRBT), TARGET :: X_IN
  REAL(KIND=JPRBT), TARGET :: X_OUT
  
  INTERFACE
    SUBROUTINE EXECUTE_PLAN_FFTH_C (KN, N, X_IN_PTR, X_OUT_PTR, PLAN_PTR) &
              & BIND(C,NAME="execute_plan_ffth_c_")
      USE, INTRINSIC :: ISO_C_BINDING
      TYPE(C_PTR), VALUE :: PLAN_PTR
      INTEGER(KIND=C_INT), VALUE :: KN
      INTEGER(KIND=C_INT), VALUE :: N
      TYPE(C_PTR), VALUE :: X_IN_PTR, X_OUT_PTR
    END SUBROUTINE EXECUTE_PLAN_FFTH_C
  END INTERFACE

#ifdef OMPGPU
  !$OMP TARGET DATA USE_DEVICE_PTR(X_IN,X_OUT)
#endif
#ifdef ACCGPU
  !$ACC HOST_DATA USE_DEVICE(X_IN,X_OUT)
#endif
  CALL EXECUTE_PLAN_FFTH_C(KN,N,C_LOC(X_IN),C_LOC(X_OUT),PLAN_PTR)
#ifdef ACCGPU
  !$ACC END HOST_DATA
#endif
#ifdef OMPGPU
  !$OMP END TARGET DATA
#endif
  
  END SUBROUTINE EXECUTE_PLAN_FFT
    
  END MODULE TPM_FFTH
  