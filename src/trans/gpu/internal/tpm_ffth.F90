! (C) Copyright 2014- ECMWF.
! 
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.
!

MODULE TPM_FFTH

  !   Author.
  !   -------
  !     George Mozdzynski
  !
  !   Modifications.
  !   -------------- 
  !     Original      October 2014
  
  USE, INTRINSIC :: ISO_C_BINDING
  
  USE PARKIND_ECTRANS ,ONLY : JPIM, JPRBT
  !USE MPL_MODULE      ,ONLY : MPL_MYRANK
  
  IMPLICIT NONE
  
  SAVE
  
  PRIVATE
  PUBLIC CREATE_PLAN_FFT, DESTROY_PLAN_FFT, DESTROY_ALL_PLANS_FFT, INIT_PLANS_FFT, EXECUTE_PLAN_FFT, &
        & FFTH_RESOL, TC
  
  TYPE FFTH_TYPE
    INTEGER(KIND=C_INT),POINTER :: N_PLANS(:)
    TYPE(FFTH_PLAN),POINTER :: FFTH_PLANS(:)
    INTEGER(KIND=C_INT) :: N_MAX=0
    INTEGER(KIND=C_INT) :: N_MAX_PLANS=8
  END TYPE FFTH_TYPE
  
  
  TYPE FFTH_PLAN
    INTEGER(KIND=C_INT) :: NPLAN_ID=123456
    TYPE(C_PTR) :: NPLAN
    INTEGER(KIND=C_INT) :: NLOT
    INTEGER(KIND=C_INT) :: NTYPE
    TYPE(FFTH_PLAN),POINTER :: NEXT_PLAN => NULL()
  END TYPE FFTH_PLAN
  
  TYPE(FFTH_TYPE),ALLOCATABLE,TARGET :: FFTH_RESOL(:)
  TYPE(FFTH_TYPE),POINTER     :: TC
  
  
  
  ! ------------------------------------------------------------------
  CONTAINS
  ! ------------------------------------------------------------------
  
  
  SUBROUTINE INIT_PLANS_FFT(KDLON)
  INTEGER(KIND=C_INT),INTENT(IN) :: KDLON
  
  TC%N_MAX=KDLON
  ALLOCATE(TC%FFTH_PLANS(TC%N_MAX))
  ALLOCATE(TC%N_PLANS(TC%N_MAX))
  TC%N_PLANS(:)=0
  RETURN  
  END SUBROUTINE INIT_PLANS_FFT
  
  
  SUBROUTINE CREATE_PLAN_FFT(KPLAN,KTYPE,KN,KLOT)
  TYPE(C_PTR),INTENT(OUT) :: KPLAN
  INTEGER(KIND=C_INT),INTENT(IN) :: KTYPE,KN,KLOT
  
  TYPE(C_PTR) :: IPLAN
  INTEGER(KIND=C_INT) :: IRANK, ISTRIDE
  INTEGER(KIND=C_INT) :: JL, JN
  INTEGER(KIND=C_INT) :: IRDIST,ICDIST,IN(1),IEMBED(1)
  LOGICAL :: LLFOUND
  LOGICAL :: LLRESTRICT_PLANS=.TRUE.
  TYPE(FFTH_PLAN),POINTER :: CURR_FFTH_PLAN,START_FFTH_PLAN
  INTERFACE
    SUBROUTINE CREATE_PLAN_FFTH(KPLAN,KTYPE,KN,KLOT) BIND(C,NAME="create_plan_ffth_")
     USE, INTRINSIC :: ISO_C_BINDING
     TYPE(C_PTR) :: KPLAN
     INTEGER(C_INT) :: KTYPE,KN,KLOT
    END SUBROUTINE CREATE_PLAN_FFTH
  END INTERFACE
  
  IF( KN > TC%N_MAX )THEN
    stop 'CREATE_PLAN_FFT: KN > N_MAX THAT WAS INITIALISED IN INIT_PLANS_FFTH'
  ENDIF
  
  IRANK=1
  ISTRIDE=1
  IN(1)=KN
  IEMBED(1)=IN(1)
  ICDIST=KN/2+1
  IRDIST=ICDIST*2
  
  !!$OMP CRITICAL
  LLFOUND=.FALSE.
  IF( TC%FFTH_PLANS(KN)%NPLAN_ID /= 123456 )THEN
    WRITE(*,'("CREATE_PLAN_FFT.1: PLAN_ID=",I10)')TC%FFTH_PLANS(KN)%NPLAN_ID
    stop 'CREATE_PLAN_FFT.1: NPLAN_ID /= 123456'
  ENDIF
  CURR_FFTH_PLAN=>TC%FFTH_PLANS(KN)
  IF( CURR_FFTH_PLAN%NPLAN_ID /= 123456 )THEN
    WRITE(*,'("CREATE_PLAN_FFT.2: PLAN_ID=",I10)')CURR_FFTH_PLAN%NPLAN_ID
    stop 'CREATE_PLAN_FFT.2: NPLAN_ID /= 123456'
  ENDIF
  ! search for plan in existing plans
  DO JL=1,TC%N_PLANS(KN)
    IF( KLOT == CURR_FFTH_PLAN%NLOT .AND. KTYPE == CURR_FFTH_PLAN%NTYPE )THEN
      LLFOUND=.TRUE.
      IPLAN=CURR_FFTH_PLAN%NPLAN
      EXIT
    ELSEIF( JL /= TC%N_PLANS(KN) )THEN
      CURR_FFTH_PLAN=>CURR_FFTH_PLAN%NEXT_PLAN
      IF( CURR_FFTH_PLAN%NPLAN_ID /= 123456 )THEN
        WRITE(*,'("CREATE_PLAN_FFT.3: PLAN_ID=",I10)')CURR_FFTH_PLAN%NPLAN_ID
        stop 'CREATE_PLAN_FFT.3: NPLAN_ID /= 123456'
      ENDIF
    ENDIF
  ENDDO
  IF( .NOT.LLFOUND )THEN
    IF( LLRESTRICT_PLANS )THEN
      IF( TC%N_PLANS(KN) == TC%N_MAX_PLANS )THEN
        ! destroy the plan at the start of the list
  !     WRITE(*,'("CREATE_PLAN_FFT: BEG: DESTROYING A PLAN AT THE START OF THE LIST")')
        CALL DESTROY_PLAN_FFT(TC%FFTH_PLANS(KN)%NPLAN)
        TC%FFTH_PLANS(KN)%NPLAN_ID=999999
        START_FFTH_PLAN=>TC%FFTH_PLANS(KN)
        TC%FFTH_PLANS(KN)=TC%FFTH_PLANS(KN)%NEXT_PLAN
        ! DEALLOCATE(START_FFTH_PLAN)
        TC%N_PLANS(KN)=TC%N_PLANS(KN)-1
  !     WRITE(*,'("CREATE_PLAN_FFT: END: DESTROYING A PLAN AT THE START OF THE LIST")')
      ENDIF
    ENDIF
    CALL CREATE_PLAN_FFTH(IPLAN,KTYPE,KN,KLOT)
    KPLAN=IPLAN
    TC%N_PLANS(KN)=TC%N_PLANS(KN)+1
    IF( TC%N_PLANS(KN) /= 1 )THEN
      ALLOCATE(CURR_FFTH_PLAN%NEXT_PLAN)
      CURR_FFTH_PLAN=>CURR_FFTH_PLAN%NEXT_PLAN
    ENDIF
    IF( CURR_FFTH_PLAN%NPLAN_ID /= 123456 )THEN
      WRITE(*,'("CREATE_PLAN_FFT.4: PLAN_ID=",I10)')CURR_FFTH_PLAN%NPLAN_ID
      stop 'CREATE_PLAN_FFT.4: NPLAN_ID /= 123456'
    ENDIF
    CURR_FFTH_PLAN%NPLAN=IPLAN
    CURR_FFTH_PLAN%NLOT=KLOT
    CURR_FFTH_PLAN%NTYPE=KTYPE
    CURR_FFTH_PLAN%NEXT_PLAN=>NULL()
  ! write(*,'("CREATE_PLAN_FFT: KN=",I5," NPLANS=",I3," KLOT=",I6," KTYPE=",I2,&
  !  & " NEW IPLAN=",Z16)')KN,TC%N_PLANS(KN),KLOT,KTYPE,IPLAN
  ELSE
    KPLAN=IPLAN
  ! write(*,'("CREATE_PLAN_FFT: KN=",I5," NPLANS=",I3," KLOT=",I6," KTYPE=",I2,&
  !  & " CUR IPLAN=",Z16)')KN,TC%N_PLANS(KN),KLOT,KTYPE,IPLAN
  ENDIF
  !!$OMP END CRITICAL
  
  RETURN
  END SUBROUTINE CREATE_PLAN_FFT
  
  
  SUBROUTINE DESTROY_PLAN_FFT(KPLAN)
  TYPE(C_PTR),INTENT(IN) :: KPLAN
  CALL DESTROY_PLAN_FFTH(KPLAN)
  RETURN
  END SUBROUTINE DESTROY_PLAN_FFT
  
  
  SUBROUTINE DESTROY_ALL_PLANS_FFT
  INTEGER(KIND=C_INT) :: JL, JN
  TYPE(FFTH_PLAN),POINTER :: CURR_FFTH_PLAN
  DO JN=1,TC%N_MAX
    CURR_FFTH_PLAN=>TC%FFTH_PLANS(JN)
  ENDDO
  !WRITE(*,'("DESTROY_ALL_PLANS_FFTH: MPL_RANK=",I6," SUM(TC%N_PLANS(:))=",I10)')&
  !  & MPL_MYRANK(), SUM(TC%N_PLANS(:))
  DEALLOCATE(TC%FFTH_PLANS)
  DEALLOCATE(TC%N_PLANS)
  RETURN
  END SUBROUTINE DESTROY_ALL_PLANS_FFT
  
  SUBROUTINE EXECUTE_PLAN_FFT(KN,N,X_IN,X_OUT,PLAN_PTR)
  TYPE(C_PTR) :: PLAN_PTR
  INTEGER(KIND=C_INT) :: KN
  INTEGER(KIND=C_INT) :: N
  REAL(KIND=JPRBT), TARGET :: X_IN
  REAL(KIND=JPRBT), TARGET :: X_OUT
  
  INTERFACE
    SUBROUTINE EXECUTE_PLAN_FFTH_C (KN, N, X_IN_PTR, X_OUT_PTR, PLAN_PTR) &
              & BIND(C,NAME="execute_plan_ffth_c_")
      USE, INTRINSIC :: ISO_C_BINDING
      TYPE(C_PTR), VALUE :: PLAN_PTR
      INTEGER(KIND=C_INT), VALUE :: KN
      INTEGER(KIND=C_INT), VALUE :: N
      TYPE(C_PTR), VALUE :: X_IN_PTR, X_OUT_PTR
    END SUBROUTINE EXECUTE_PLAN_FFTH_C
  END INTERFACE

#ifdef OMPGPU
  !$OMP TARGET DATA USE_DEVICE_PTR(X_IN,X_OUT)
#endif
#ifdef ACCGPU
  !$ACC HOST_DATA USE_DEVICE(X_IN,X_OUT)
#endif
  CALL EXECUTE_PLAN_FFTH_C(KN,N,C_LOC(X_IN),C_LOC(X_OUT),PLAN_PTR)
#ifdef ACCGPU
  !$ACC END HOST_DATA
#endif
#ifdef OMPGPU
  !$OMP END TARGET DATA
#endif
  
  END SUBROUTINE EXECUTE_PLAN_FFT
    
  END MODULE TPM_FFTH
  