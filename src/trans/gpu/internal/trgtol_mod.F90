! (C) Copyright 1995- ECMWF.
! (C) Copyright 1995- Meteo-France.
! 
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.
!

MODULE TRGTOL_MOD
  CONTAINS
#ifdef USE_CUDA_AWARE_MPI_FT
SUBROUTINE TRGTOL_CUDAAWARE(PGLAT,KF_FS,KF_GP,KF_SCALARS_G,KVSET,KPTRGP,&
   &PGP,PGPUV,PGP3A,PGP3B,PGP2)
  
  !**** *TRGTOL * - transposition of grid point data from column
  !                 structure to latitudinal. Reorganize data between
  !                 grid point calculations and direct Fourier Transform
  
  ! Version using CUDA-aware MPI

  !     Purpose.
  !     --------
  
  
  !**   Interface.
  !     ----------
  !        *call* *trgtol(...)
  
  !        Explicit arguments :
  !        --------------------
  !           PGLAT    -  Latitudinal data ready for direct FFT (output)
  !           PGP    -  Blocked grid point data    (input)
  
  !        Implicit arguments :
  !        --------------------
  
  !     Method.
  !     -------
  !        See documentation
  
  !     Externals.
  !     ----------
  
  !     Reference.
  !     ----------
  !        ECMWF Research Department documentation of the IFS
  
  !     Author.
  !     -------
  !        MPP Group *ECMWF*
  
  !     Modifications.
  !     --------------
  !        Original: 95-10-01
  !        D.Dent  : 97-08-04   Reorganisation to allow
  !                             NPRTRV to differ from NPRGPEW
  !                : 98-06-17   add mailbox control logic (from TRLTOM)
  !        =99-03-29= Mats Hamrud and Deborah Salmond
  !                   JUMP in FFT's changed to 1
  !                   KINDEX introduced and ZCOMBUF not used for same PE
  !         01-11-23  Deborah Salmond and John Hague
  !                    LIMP_NOOLAP Option for non-overlapping message passing
  !                    and buffer packing
  !         01-12-18  Peter Towers
  !                   Improved vector performance of GTOL_PACK,GTOL_UNPACK
  !         03-04-02  G. Radnoti: call barrier always when nproc>1
  !         08-01-01  G.Mozdzynski: cleanup
  !         09-01-02  G.Mozdzynski: use non-blocking recv and send
  !     ------------------------------------------------------------------
  
  
  
  USE PARKIND_ECTRANS ,ONLY : JPIM     ,JPRB,  JPRBT
  USE YOMHOOK         ,ONLY : LHOOK,   DR_HOOK, JPHOOK
  
  USE MPL_MODULE      ,ONLY : MPL_RECV, MPL_SEND, MPL_WAIT, JP_NON_BLOCKING_STANDARD, MPL_BARRIER
  
  USE TPM_GEN         ,ONLY : NOUT, LSYNC_TRANS
  USE TPM_DISTR       ,ONLY : D, NPRCIDS, NPRTRNS, MTAGGL,  &
       &                      MYSETV, MYSETW, MYPROC, NPROC
  USE TPM_TRANS       ,ONLY : LDIVGP, LGPNORM, LSCDERS, LUVDER, LVORGP, NGPBLKS
  
  USE INIGPTR_MOD     ,ONLY : INIGPTR
  USE PE2SET_MOD      ,ONLY : PE2SET
  !USE MYSENDSET_MOD
  USE MPL_DATA_MODULE ,ONLY : MPL_COMM_OML
  USE OML_MOD         ,ONLY : OML_MY_THREAD
  !USE MYRECVSET_MOD
  USE ABORT_TRANS_MOD ,ONLY : ABORT_TRANS
  !
#ifdef ACCGPU
  USE MPI
#endif
  
  IMPLICIT NONE
  
#ifdef OMPGPU
  include 'mpif.h'
#endif

  REAL(KIND=JPRBT),INTENT(OUT)   :: PGLAT(:,:)
  INTEGER(KIND=JPIM),INTENT(IN) :: KVSET(:)
  INTEGER(KIND=JPIM),INTENT(IN) :: KF_FS,KF_GP
  INTEGER(KIND=JPIM),INTENT(IN) :: KF_SCALARS_G
  INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KPTRGP(:)
  REAL(KIND=JPRB),OPTIONAL,INTENT(IN)     :: PGP(:,:,:)
  REAL(KIND=JPRB),OPTIONAL,INTENT(IN)     :: PGPUV(:,:,:,:)
  REAL(KIND=JPRB),OPTIONAL,INTENT(IN)     :: PGP3A(:,:,:,:)
  REAL(KIND=JPRB),OPTIONAL,INTENT(IN)     :: PGP3B(:,:,:,:)
  REAL(KIND=JPRB),OPTIONAL,INTENT(IN)     :: PGP2(:,:,:)
  
  REAL(KIND=JPRBT),ALLOCATABLE :: ZCOMBUFS(:,:),ZCOMBUFR(:,:)
  INTEGER(KIND=JPIM)           :: ICOMBUFS_FLD(NPROC),ICOMBUFR_FLD(NPROC)
  REAL(KIND=JPRBT) :: ZDUM(2)
  
  INTEGER(KIND=JPIM) :: ISENT    (NPROC)
  INTEGER(KIND=JPIM) :: IRCVD    (NPROC)
  INTEGER(KIND=JPIM) :: ISENDTOT (NPROC)
  INTEGER(KIND=JPIM) :: IRECVTOT (NPROC)
  INTEGER(KIND=JPIM) :: IREQ     (NPROC*4)
  INTEGER(KIND=JPIM) :: JRECV    (NPROC)
  INTEGER(KIND=JPIM) :: JSEND    (NPROC)
  
  !     LOCAL INTEGER SCALARS
  INTEGER(KIND=JPIM) :: IFIRST, IFIRSTLAT, IGL, IGLL, ILAST,&
               &ILASTLAT, ILEN, JROC, IPOS, ISETA, &
               &ISETB, IRECV, IRECVSET, &
               &ISETV, ISEND, ISENDSET, ITAG, J, JBLK, JFLD, &
               &JGL, JK, JL, JLOOP, ISETW,  IFLD, &
               &II,INDOFFX,IBUFLENS,IBUFLENR,INRECV, IPROC,IFLDS, &
               &INSEND,INS,INR,IR, IUNIT, JKL, JK_MAX
  
  !     LOCAL LOGICAL SCALARS
  LOGICAL   :: LLPGPUV,LLPGP3A,LLPGP3B,LLPGP2,LLPGPONLY
  LOGICAL   :: LLUV(KF_GP),LLGP2(KF_GP),LLGP3A(KF_GP),LLGP3B(KF_GP)
  LOGICAL :: LLDONE, LLINDER
  INTEGER(KIND=JPIM) :: IUVLEVS(KF_GP),IUVPARS(KF_GP),IGP2PARS(KF_GP)
  INTEGER(KIND=JPIM) :: IGP3APARS(KF_GP),IGP3ALEVS(KF_GP),IGP3BPARS(KF_GP),IGP3BLEVS(KF_GP)
  INTEGER(KIND=JPIM) :: IUVPAR,IUVLEV,IGP2PAR,IGP3ALEV,IGP3APAR,IGP3BLEV,IGP3BPAR,IPAROFF
  INTEGER(KIND=JPIM) :: IOFF,IOFF1,IOFFNS,IOFFEW,J1,J2
  INTEGER(KIND=JPIM) :: KINDEX(D%NLENGTF),INDOFF(NPROC),IFLDOFF(MAX(KF_GP,KF_FS))
  INTEGER(KIND=JPIM) :: ISEND_FLD_TOTAL(NPROC),ISEND_FLD_END
  INTEGER(KIND=JPIM) :: IRECV_FLD_END
  INTEGER(KIND=JPIM) :: INUMFLDS
  INTEGER(KIND=JPIM) :: IGPTRSEND(2,NGPBLKS,NPRTRNS)
  INTEGER(KIND=JPIM) :: IGPTRRECV(NPRTRNS)
  INTEGER(KIND=JPIM) :: IGPTROFF(NGPBLKS)
  !     INTEGER FUNCTIONS
  INTEGER(KIND=JPIM) :: IRECVCOUNT,ISENDCOUNT
  INTEGER(KIND=JPIM) :: IJPOS(NGPBLKS),IFLDA(KF_GP),JJ,JI,IFLDT
  REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
  REAL(KIND=JPHOOK) :: ZHOOK_HANDLE_BAR
  
  INTEGER(KIND=JPIM) :: IERROR, irank
  
  REAL(KIND=JPRBT) :: TIMEF, tc
  
#ifdef PARKINDTRANS_SINGLE
#define TRGTOL_DTYPE MPI_REAL
#else
#define TRGTOL_DTYPE MPI_DOUBLE_PRECISION
#endif

  !     ------------------------------------------------------------------
  
  !*       0.    Some initializations
  !              --------------------
  
  IF (LHOOK) CALL DR_HOOK('TRGTOL_CUDAAWARE',0,ZHOOK_HANDLE)
  
  iunit=300+myproc

  CALL GSTATS(1805,0)
  
  LLINDER = .FALSE.
  LLPGPUV = .FALSE.
  LLPGP3A = .FALSE.
  LLPGP3B = .FALSE.
  LLPGP2  = .FALSE.
  LLPGPONLY = .FALSE.
  IF(PRESENT(KPTRGP))  LLINDER = .TRUE.
  IF(PRESENT(PGP))     LLPGPONLY = .TRUE.
  IF(PRESENT(PGPUV))   LLPGPUV = .TRUE.
  IF(PRESENT(PGP3A))   LLPGP3A = .TRUE.
  IF(PRESENT(PGP3B))   LLPGP3B = .TRUE.
  IF(PRESENT(PGP2))    LLPGP2 = .TRUE.
  IUVPAR=0
  IUVLEV=0
  IOFF1=0
  IOFFNS=KF_SCALARS_G
  IOFFEW=2*KF_SCALARS_G
  LLUV(:) = .FALSE.
  IUVPARS(:) = -99
  IUVLEVS(:) = -99
  IF (LLPGPUV) THEN
    IOFF=0
    IUVLEV=UBOUND(PGPUV,2)
    IF(LVORGP) THEN
      IUVPAR=IUVPAR+1
      DO J=1,IUVLEV
        IUVLEVS(IOFF+J)=J
        IUVPARS(IOFF+J)=IUVPAR
        LLUV(IOFF+J)=.TRUE.
      ENDDO
      IOFF=IOFF+IUVLEV
    ENDIF
    IF(LDIVGP) THEN
      IUVPAR=IUVPAR+1
      DO J=1,IUVLEV
        IUVLEVS(IOFF+J)=J
        IUVPARS(IOFF+J)=IUVPAR
        LLUV(IOFF+J)=.TRUE.
      ENDDO
      IOFF=IOFF+IUVLEV
    ENDIF
    DO J=1,IUVLEV
      IUVLEVS(IOFF+J)=J
      IUVPARS(IOFF+J)=IUVPAR+1
      IUVLEVS(IOFF+J+IUVLEV)=J
      IUVPARS(IOFF+J+IUVLEV)=IUVPAR+2
    ENDDO
    IUVPAR=IUVPAR+2
    LLUV(IOFF+1:IOFF+2*IUVLEV)=.TRUE.
    IOFF=IOFF+2*IUVLEV
    IOFF1=IOFF
    IOFFNS=IOFFNS+IOFF
    IOFFEW=IOFFEW+IOFF
    IOFF=IUVPAR*IUVLEV+KF_SCALARS_G
    IF(LUVDER) THEN
      IF(LSCDERS) IOFF=IOFF+KF_SCALARS_G
      DO J=1,IUVLEV
        IUVLEVS(IOFF+J)=J
        IUVPARS(IOFF+J)=IUVPAR+1
        LLUV(IOFF+J)=.TRUE.
        IUVLEVS(IOFF+J+IUVLEV)=J
        IUVPARS(IOFF+J+IUVLEV)=IUVPAR+2
        LLUV(IOFF+J+IUVLEV)=.TRUE.
      ENDDO
      IUVPAR=IUVPAR+2
      IOFF=IOFF+2*IUVLEV
      IOFFEW=IOFFEW+2*IUVLEV
    ENDIF
  ENDIF
  LLGP2(:)=.FALSE.
  IF(LLPGP2) THEN
    IOFF=IOFF1
    IGP2PAR=UBOUND(PGP2,2)
    IF(LSCDERS) IGP2PAR=IGP2PAR/3
    DO J=1,IGP2PAR
      LLGP2(J+IOFF) = .TRUE.
      IGP2PARS(J+IOFF)=J
    ENDDO
    IOFF1=IOFF1+IGP2PAR
    IF(LSCDERS) THEN
      IOFF=IOFFNS
      DO J=1,IGP2PAR
        LLGP2(J+IOFF) = .TRUE.
        IGP2PARS(J+IOFF)=J+IGP2PAR
      ENDDO
      IOFFNS=IOFF+IGP2PAR
      IOFF=IOFFEW
      DO J=1,IGP2PAR
        LLGP2(J+IOFF) = .TRUE.
        IGP2PARS(J+IOFF)=J+2*IGP2PAR
      ENDDO
      IOFFEW=IOFF+IGP2PAR
    ENDIF
  ENDIF
  LLGP3A(:) = .FALSE.
  IF(LLPGP3A) THEN
    IGP3ALEV=UBOUND(PGP3A,2)
    IGP3APAR=UBOUND(PGP3A,3)
    IF(LSCDERS) IGP3APAR=IGP3APAR/3
    IOFF=IOFF1
    DO J1=1,IGP3APAR
      DO J2=1,IGP3ALEV
        LLGP3A(J2+(J1-1)*IGP3ALEV+IOFF) = .TRUE.
        IGP3APARS(J2+(J1-1)*IGP3ALEV+IOFF)=J1
        IGP3ALEVS(J2+(J1-1)*IGP3ALEV+IOFF)=J2
      ENDDO
    ENDDO
    IPAROFF=IGP3APAR
    IOFF1=IOFF1+IGP3APAR*IGP3ALEV
    IF(LSCDERS) THEN
      IOFF=IOFFNS
      DO J1=1,IGP3APAR
        DO J2=1,IGP3ALEV
          LLGP3A(J2+(J1-1)*IGP3ALEV+IOFF) = .TRUE.
          IGP3APARS(J2+(J1-1)*IGP3ALEV+IOFF)=J1+IPAROFF
          IGP3ALEVS(J2+(J1-1)*IGP3ALEV+IOFF)=J2
        ENDDO
      ENDDO
      IPAROFF=IPAROFF+IGP3APAR
      IOFFNS=IOFFNS+IGP3APAR*IGP3ALEV
      IOFF=IOFFEW
      DO J1=1,IGP3APAR
        DO J2=1,IGP3ALEV
          LLGP3A(J2+(J1-1)*IGP3ALEV+IOFF) = .TRUE.
          IGP3APARS(J2+(J1-1)*IGP3ALEV+IOFF)=J1+IPAROFF
          IGP3ALEVS(J2+(J1-1)*IGP3ALEV+IOFF)=J2
        ENDDO
      ENDDO
      IOFFEW=IOFFEW+IGP3APAR*IGP3ALEV
    ENDIF
  ENDIF
  LLGP3B(:) = .FALSE.
  IF(LLPGP3B) THEN
    IGP3BLEV=UBOUND(PGP3B,2)
    IGP3BPAR=UBOUND(PGP3B,3)
    IF(LSCDERS) IGP3BPAR=IGP3BPAR/3
    IOFF=IOFF1
    DO J1=1,IGP3BPAR
      DO J2=1,IGP3BLEV
        LLGP3B(J2+(J1-1)*IGP3BLEV+IOFF) = .TRUE.
        IGP3BPARS(J2+(J1-1)*IGP3BLEV+IOFF)=J1
        IGP3BLEVS(J2+(J1-1)*IGP3BLEV+IOFF)=J2
      ENDDO
    ENDDO
    IPAROFF=IGP3BPAR
    IOFF1=IOFF1+IGP3BPAR*IGP3BLEV
    IF(LSCDERS) THEN
      IOFF=IOFFNS
      DO J1=1,IGP3BPAR
        DO J2=1,IGP3BLEV
          LLGP3B(J2+(J1-1)*IGP3BLEV+IOFF) = .TRUE.
          IGP3BPARS(J2+(J1-1)*IGP3BLEV+IOFF)=J1+IPAROFF
          IGP3BLEVS(J2+(J1-1)*IGP3BLEV+IOFF)=J2
        ENDDO
      ENDDO
      IPAROFF=IPAROFF+IGP3BPAR
      IOFFNS=IOFFNS+IGP3BPAR*IGP3BLEV
      IOFF=IOFFEW
      DO J1=1,IGP3BPAR
        DO J2=1,IGP3BLEV
          LLGP3B(J2+(J1-1)*IGP3BLEV+IOFF) = .TRUE.
          IGP3BPARS(J2+(J1-1)*IGP3BLEV+IOFF)=J1+IPAROFF
          IGP3BLEVS(J2+(J1-1)*IGP3BLEV+IOFF)=J2
        ENDDO
      ENDDO
      IOFFEW=IOFFEW+IGP3BPAR*IGP3BLEV
    ENDIF
  ENDIF
  
  
  CALL INIGPTR(IGPTRSEND,IGPTRRECV)
  LLDONE = .FALSE.
  
#ifdef ACCGPU
  !$ACC DATA COPYIN(LLGP2,LLGP3A,LLGP3B,LLUV,IGPTRSEND)
#endif
#ifdef OMPGPU
  !$OMP TARGET DATA MAP(TO:LLGP2,LLGP3A,LLGP3B,LLUV,IGPTRSEND)
#endif
  
  ITAG = MTAGGL
  
  INDOFFX  = 0
  IBUFLENS = 0
  IBUFLENR = 0
  INRECV   = 0
  INSEND   = 0
  
  DO JROC=1,NPROC
  
    CALL PE2SET(JROC,ISETA,ISETB,ISETW,ISETV)
    IRECVSET = ISETA
    ISEND = JROC
    ISENDSET = ISETV
    ISENT(JROC) = 0
    IRCVD(JROC) = 0
  
  !             count up expected number of fields
    IPOS = 0
    DO JFLD=1,KF_GP
      IF(KVSET(JFLD) == ISENDSET .OR. KVSET(JFLD) == -1) IPOS = IPOS+1
    ENDDO
    ISEND_FLD_TOTAL(JROC) = IPOS
    ISENDTOT(JROC) = IGPTRRECV(ISETW)*IPOS
  
    IF( JROC /= MYPROC) THEN
      IBUFLENS = MAX(IBUFLENS,ISENDTOT(JROC))
      IF(ISENDTOT(JROC) > 0) THEN
        INSEND = INSEND+1
        JSEND(INSEND)=JROC
      ENDIF
    ENDIF
  
    IFIRSTLAT = MAX(D%NPTRLS(MYSETW),D%NFRSTLAT(IRECVSET))
    ILASTLAT  = MIN(D%NPTRLS(MYSETW)+D%NULTPP(MYSETW)-1,D%NLSTLAT(IRECVSET))
  
    IPOS = 0
    DO JGL=IFIRSTLAT,ILASTLAT
      IGL  = D%NPTRFRSTLAT(IRECVSET)+JGL-D%NFRSTLAT(IRECVSET)
      IPOS = IPOS+D%NONL(IGL,ISETB)
    ENDDO
  
    IRECVTOT(JROC) = IPOS*KF_FS
  
    IF(IRECVTOT(JROC) > 0 .AND. MYPROC /= JROC) THEN
      INRECV = INRECV + 1
      JRECV(INRECV)=JROC
    ENDIF
  
    IF( JROC /= MYPROC) IBUFLENR = MAX(IBUFLENR,IRECVTOT(JROC))
  
    IF(IPOS > 0) THEN
      INDOFF(JROC) = INDOFFX
      INDOFFX = INDOFFX+IPOS
      IPOS = 0
      DO JGL=IFIRSTLAT,ILASTLAT
        IGL  = D%NPTRFRSTLAT(IRECVSET)+JGL-D%NFRSTLAT(IRECVSET)
        IGLL = JGL-D%NPTRLS(MYSETW)+1
        DO JL=D%NSTA(IGL,ISETB)+D%NSTAGTF(IGLL),&
         &D%NSTA(IGL,ISETB)+D%NSTAGTF(IGLL)+D%NONL(IGL,ISETB)-1
          IPOS = IPOS+1
          KINDEX(IPOS+INDOFF(JROC)) = JL
        ENDDO
      ENDDO
    ENDIF
  
  ENDDO
  
  ISENDCOUNT=0
  IRECVCOUNT=0
  DO J=1,NPROC
    ISENDCOUNT=MAX(ISENDCOUNT,ISENDTOT(J))
    IRECVCOUNT=MAX(IRECVCOUNT,IRECVTOT(J))
  ENDDO

  IF (IBUFLENS > 0) ALLOCATE(ZCOMBUFS(ISENDCOUNT,INSEND))
  IF (IBUFLENR > 0) ALLOCATE(ZCOMBUFR(IRECVCOUNT,INRECV))
#ifdef ACCGPU
  !$ACC DATA IF(IBUFLENS > 0) CREATE(ZCOMBUFS)
#endif
#ifdef OMPGPU
  !$OMP TARGET DATA IF(IBUFLENS > 0) MAP(ALLOC:ZCOMBUFS)
#endif
#ifdef ACCGPU
  !$ACC DATA IF(IBUFLENR > 0) CREATE(ZCOMBUFR)
#endif
#ifdef OMPGPU
  !$OMP TARGET DATA IF(IBUFLENR > 0) MAP(ALLOC:ZCOMBUFR)
#endif

#ifdef OMPGPU
  !$OMP TARGET
#endif
#ifdef ACCGPU
  !$ACC KERNELS DEFAULT(NONE) PRESENT(IBUFLENS, IBUFLENR)
#endif
  IF (IBUFLENS > 0) ZCOMBUFS(:,:) =  0.
  IF (IBUFLENR > 0) ZCOMBUFR(:,:) =  0.
#ifdef ACCGPU
  !$ACC END KERNELS
#endif
#ifdef OMPGPU
  !$OMP END TARGET
#endif

  CALL GSTATS(1805,1)
 
  ! Send loop.............................................................
  
  ! Copy local contribution
#ifdef ACCGPU
  !$ACC DATA PRESENT(PGLAT) COPYIN(KPTRGP,INDOFF,KINDEX)
  !$ACC DATA IF(PRESENT(PGP))   PRESENT(PGP)
  !$ACC DATA IF(PRESENT(PGPUV)) PRESENT(PGPUV) COPYIN(IUVLEVS,IUVPARS)
  !$ACC DATA IF(PRESENT(PGP2))  PRESENT(PGP2)  COPYIN(IGP2PARS)
  !$ACC DATA IF(PRESENT(PGP3A)) PRESENT(PGP3A) COPYIN(IGP3ALEVS,IGP3APARS)
  !$ACC DATA IF(PRESENT(PGP3B)) PRESENT(PGP3B) COPYIN(IGP3BLEVS,IGP3BPARS)
#endif
#ifdef OMPGPU
!WARNING: following lines should be PRESENT,ALLOC but cause issues with AMD compiler!
  !$OMP TARGET DATA MAP(ALLOC:PGLAT) MAP(TO:KPTRGP,INDOFF,KINDEX)
  !$OMP TARGET DATA IF(PRESENT(PGP))   MAP(ALLOC:PGP)
  !$OMP TARGET DATA IF(PRESENT(PGPUV)) MAP(ALLOC:PGPUV) MAP(TO:IUVLEVS,IUVPARS)
  !$OMP TARGET DATA IF(PRESENT(PGP2))  MAP(ALLOC:PGP2)  MAP(TO:IGP2PARS)
  !$OMP TARGET DATA IF(PRESENT(PGP3A)) MAP(ALLOC:PGP3A) MAP(TO:IGP3ALEVS,IGP3APARS)
  !$OMP TARGET DATA IF(PRESENT(PGP3B)) MAP(ALLOC:PGP3B) MAP(TO:IGP3BLEVS,IGP3BPARS)
#endif
  
  IF(ISENDTOT(MYPROC) > 0 )THEN
    IFLDS = 0
    DO JFLD=1,KF_GP
      IF(KVSET(JFLD) == MYSETV .OR. KVSET(JFLD) == -1) THEN
        IFLDS = IFLDS+1
        IF(LLINDER) THEN
          IFLDOFF(IFLDS) = KPTRGP(JFLD)
        ELSE
          IFLDOFF(IFLDS) = JFLD
        ENDIF
      ENDIF
    ENDDO
  
    IPOS=0
    JK_MAX = 0
    DO JBLK=1,NGPBLKS
      IGPTROFF(JBLK)=IPOS
      IFIRST = IGPTRSEND(1,JBLK,MYSETW)
      IF(IFIRST > 0) THEN
        ILAST = IGPTRSEND(2,JBLK,MYSETW)
        IPOS=IPOS+ILAST-IFIRST+1
        IF (JK_MAX<(ILAST-IFIRST+1)) JK_MAX = (ILAST-IFIRST+1)
      ENDIF
    ENDDO

#ifdef ACCGPU
  !$ACC DATA COPYIN(IFLDOFF,IGPTROFF)
#endif
#ifdef OMPGPU
  !$OMP TARGET DATA MAP(TO:IFLDOFF,IGPTROFF)
#endif

  CALL GSTATS(1601,0)
  IF(LLPGPONLY) THEN
#ifdef OMPGPU
    !$OMP TARGET TEAMS DISTRIBUTE PARALLEL DO COLLAPSE(3) DEFAULT(NONE) PRIVATE(IPOS,IFIRST,ILAST,IFLD,JK) &
    !$OMP& SHARED(NGPBLKS,IFLDS,JK_MAX,IGPTRSEND,MYSETW,INDOFF,MYPROC,IGPTROFF,IFLDOFF,KINDEX,PGLAT,PGP)
#endif
#ifdef ACCGPU
    !$ACC PARALLEL LOOP COLLAPSE(3) DEFAULT(NONE) PRIVATE(IPOS,IFIRST,ILAST,IFLD,JK) &
    !$ACC& PRESENT(NGPBLKS,IFLDS,JK_MAX,IGPTRSEND,MYSETW,INDOFF,MYPROC,IGPTROFF,IFLDOFF,KINDEX,PGLAT,PGP)
#endif
    DO JBLK=1,NGPBLKS
      DO JFLD=1,IFLDS
        DO JKL=1, JK_MAX
          IFIRST = IGPTRSEND(1,JBLK,MYSETW)
          ILAST = IGPTRSEND(2,JBLK,MYSETW)
          JK = JKL+IFIRST-1
          IF(IFIRST > 0 .AND. JK <= ILAST) THEN
            IPOS = INDOFF(MYPROC)+IGPTROFF(JBLK)+JK-IFIRST+1
            IFLD = IFLDOFF(JFLD)
            PGLAT(JFLD,KINDEX(IPOS)) = PGP(JK,IFLD,JBLK)
          ENDIF
        ENDDO
      ENDDO
    ENDDO
  ELSE
#ifdef OMPGPU
    !$OMP TARGET TEAMS DISTRIBUTE PARALLEL DO COLLAPSE(3) DEFAULT(NONE) PRIVATE(IPOS,IFIRST,ILAST,IFLD,JK) &
    !$OMP& SHARED(NGPBLKS,IFLDS,JK_MAX,IGPTRSEND,MYSETW,INDOFF,MYPROC,IGPTROFF,IFLDOFF, &
    !$OMP&        LLUV,LLGP2,LLGP3A,LLGP3B,PGLAT,KINDEX,PGPUV,PGP2,PGP3A,PGP3B,IUVLEVS, &
    !$OMP&        IUVPARS,IGP2PARS,IGP3ALEVS,IGP3APARS,IGP3BLEVS,IGP3BPARS)
#endif
#ifdef ACCGPU
    !$ACC PARALLEL LOOP COLLAPSE(3) DEFAULT(NONE) PRIVATE(IPOS,IFIRST,ILAST,IFLD,JK) &
    !$ACC& PRESENT(NGPBLKS,IFLDS,JK_MAX,IGPTRSEND,MYSETW,INDOFF,MYPROC,IGPTROFF,IFLDOFF, &
    !$ACC&        LLUV,LLGP2,LLGP3A,LLGP3B,PGLAT,KINDEX,PGPUV,PGP2,PGP3A,PGP3B,IUVLEVS, &
    !$ACC&        IUVPARS,IGP2PARS,IGP3ALEVS,IGP3APARS,IGP3BLEVS,IGP3BPARS)
#endif
    DO JBLK=1,NGPBLKS
      DO JFLD=1,IFLDS
        DO JKL=1, JK_MAX
          IFIRST = IGPTRSEND(1,JBLK,MYSETW)
          ILAST = IGPTRSEND(2,JBLK,MYSETW)
          JK = JKL+IFIRST-1
          IF(IFIRST > 0 .AND. JK <= ILAST) THEN
            IPOS = INDOFF(MYPROC)+IGPTROFF(JBLK)+JK-IFIRST+1
            IFLD = IFLDOFF(JFLD)
            IF(LLUV(IFLD)) THEN
              PGLAT(JFLD,KINDEX(IPOS)) = PGPUV(JK,IUVLEVS(IFLD),IUVPARS(IFLD),JBLK)
            ELSEIF(LLGP2(IFLD)) THEN
              PGLAT(JFLD,KINDEX(IPOS)) = PGP2(JK,IGP2PARS(IFLD),JBLK)
            ELSEIF(LLGP3A(IFLD)) THEN
              PGLAT(JFLD,KINDEX(IPOS)) = PGP3A(JK,IGP3ALEVS(IFLD),IGP3APARS(IFLD),JBLK)
            ELSEIF(LLGP3B(IFLD)) THEN
              PGLAT(JFLD,KINDEX(IPOS)) = PGP3B(JK,IGP3BLEVS(IFLD),IGP3BPARS(IFLD),JBLK)
            ENDIF
          ENDIF
        ENDDO
      ENDDO
    ENDDO
   ENDIF
   CALL GSTATS(1601,1)

#ifdef OMPGPU
   !$OMP END TARGET DATA
#endif
#ifdef ACCGPU
   !$ACC END DATA
#endif

  ENDIF

#ifdef COMVERBOSE
    call MPI_BARRIER(MPI_COMM_WORLD,IERROR)
    Tc=TIMEF()
#endif
  !....Pack loop.........................................................
  
  CALL GSTATS(1602,0)
    DO INS=1,INSEND
      ISEND=JSEND(INS)
      CALL PE2SET(ISEND,ISETA,ISETB,ISETW,ISETV)
      ISENDSET = ISETV
      ISEND_FLD_END = ISEND_FLD_TOTAL(ISEND)
      IFLD = 0
      IPOS = 0
      DO JFLD=1,KF_GP
        IF(KVSET(JFLD) == ISENDSET .OR. KVSET(JFLD) == -1 ) THEN
          IFLD = IFLD+1
          IFLDA(IFLD)=JFLD
        ENDIF
      ENDDO
  
      JK_MAX = 0
      DO JBLK=1,NGPBLKS
        IFIRST = IGPTRSEND(1,JBLK,ISETW)
        IF(IFIRST > 0) THEN
          ILAST = IGPTRSEND(2,JBLK,ISETW)
          IJPOS(JBLK)=IPOS
          IPOS = IPOS+ILAST-IFIRST+1
          IF (JK_MAX<(ILAST-IFIRST+1)) JK_MAX = (ILAST-IFIRST+1)
        ENDIF
      ENDDO
  
  
#ifdef OMPGPU
      !$OMP TARGET TEAMS DISTRIBUTE PARALLEL DO COLLAPSE(3) DEFAULT(NONE) PRIVATE(JK,JI,IFLDT,IFIRST,ILAST) &
      !$OMP& SHARED(ISEND_FLD_END,NGPBLKS,IFLDA,ISETW,IPOS,JK_MAX,IGPTRSEND,IJPOS,LLINDER,LLPGPONLY, &
      !$OMP&        LLUV,LLGP2,LLGP3A,LLGP3B,ZCOMBUFS,INS,KPTRGP,PGP,PGPUV,PGP2,PGP3A,PGP3B,IUVLEVS, &
      !$OMP&        IUVPARS,IGP2PARS,IGP3ALEVS,IGP3APARS,IGP3BLEVS,IGP3BPARS)
#endif
#ifdef ACCGPU
      !$ACC PARALLEL LOOP COLLAPSE(3) DEFAULT(NONE) PRIVATE(JK,JI,IFLDT,IFIRST,ILAST) COPYIN(INS,JK_MAX,IJPOS,IFLDA) &
      !$ACC& PRESENT(ISEND_FLD_END,NGPBLKS,IFLDA,ISETW,IPOS,JK_MAX,IGPTRSEND,IJPOS,LLINDER,LLPGPONLY, &
      !$ACC&        LLUV,LLGP2,LLGP3A,LLGP3B,ZCOMBUFS,INS,KPTRGP,PGP,PGPUV,PGP2,PGP3A,PGP3B,IUVLEVS, &
      !$ACC&        IUVPARS,IGP2PARS,IGP3ALEVS,IGP3APARS,IGP3BLEVS,IGP3BPARS)
#endif
      DO JJ=1,ISEND_FLD_END
        DO JBLK=1,NGPBLKS
          DO JKL=1, JK_MAX
            IFLDT=IFLDA(JJ)
            IFIRST = IGPTRSEND(1,JBLK,ISETW)
            ILAST = IGPTRSEND(2,JBLK,ISETW)
            JK = JKL+IFIRST-1
            JI=(JJ-1)*IPOS+IJPOS(JBLK)+JKL
            IF(IFIRST > 0 .AND. JK <= ILAST) THEN
              IF(LLINDER) THEN
                ZCOMBUFS(JI,INS) = PGP(JK,KPTRGP(IFLDT),JBLK)
              ELSEIF(LLPGPONLY) THEN
                ZCOMBUFS(JI,INS) = PGP(JK,IFLDT,JBLK)
              ELSEIF(LLUV(IFLDT)) THEN
                ZCOMBUFS(JI,INS) = PGPUV(JK,IUVLEVS(IFLDT),IUVPARS(IFLDT),JBLK)
              ELSEIF(LLGP2(IFLDT)) THEN
                ZCOMBUFS(JI,INS) = PGP2(JK,IGP2PARS(IFLDT),JBLK)
              ELSEIF(LLGP3A(IFLDT)) THEN
                ZCOMBUFS(JI,INS) = PGP3A(JK,IGP3ALEVS(IFLDT),IGP3APARS(IFLDT),JBLK)
              ELSEIF(LLGP3B(IFLDT)) THEN
                ZCOMBUFS(JI,INS) = PGP3B(JK,IGP3BLEVS(IFLDT),IGP3BPARS(IFLDT),JBLK)
              ENDIF
            ENDIF
          ENDDO
        ENDDO
      ENDDO
  
      ICOMBUFS_FLD(INS) = IFLD
    ENDDO


#ifdef COMVERBOSE
    call MPI_BARRIER(MPI_COMM_WORLD,IERROR)
    Tc=(TIMEF()-Tc)/1000.0_JPRBT
    CALL MPI_COMM_RANK(MPI_COMM_WORLD, IRANK, IERROR)
    !IF(irank==0) WRITE(*,*) "packing (trgtol) in sec: ", Tc
#endif
  
  CALL GSTATS(1602,1)
  
  IF (LHOOK) CALL DR_HOOK('TRGTOL_BAR',0,ZHOOK_HANDLE_BAR)
  CALL GSTATS_BARRIER(761)
  IF (LHOOK) CALL DR_HOOK('TRGTOL_BAR',1,ZHOOK_HANDLE_BAR)
  
  IF(.NOT.LGPNORM)THEN
    CALL GSTATS(803,0)
  ELSE
    CALL GSTATS(804,0)
  ENDIF
  IR=0
  
#ifdef COMVERBOSE
    call MPI_BARRIER(MPI_COMM_WORLD,IERROR)
    Tc=TIMEF()
#endif
  IF (LSYNC_TRANS) THEN
    CALL GSTATS(423,0)
    CALL MPL_BARRIER(CDSTRING='TRGTOL BARRIER')
    CALL GSTATS(423,1)
  ENDIF
  CALL GSTATS(413,0)

#ifdef ACCGPU
  !$ACC HOST_DATA USE_DEVICE(ZCOMBUFR,ZCOMBUFS)
#endif
#ifdef OMPGPU
  !$OMP TARGET DATA USE_DEVICE_PTR(ZCOMBUFR,ZCOMBUFS)
#endif
  !  Receive loop.........................................................
  DO INR=1,INRECV
    IR=IR+1
    IRECV=JRECV(INR)
    CALL MPI_IRECV(ZCOMBUFR(1:IRECVTOT(IRECV),INR),IRECVTOT(IRECV), &
      & TRGTOL_DTYPE,NPRCIDS(IRECV)-1,ITAG,MPL_COMM_OML(OML_MY_THREAD()),IREQ(IR),IERROR)
    IR=IR+1
    CALL MPI_IRECV(ICOMBUFR_FLD(INR),1, &
      & MPI_INTEGER,NPRCIDS(IRECV)-1,ITAG,MPL_COMM_OML(OML_MY_THREAD()),IREQ(IR),IERROR)
  ENDDO
  
  !....Send loop.........................................................
  DO INS=1,INSEND
    IR=IR+1
    ISEND=JSEND(INS)
    CALL MPI_ISEND(ZCOMBUFS(1:ISENDTOT(ISEND),INS),ISENDTOT(ISEND), &
     & TRGTOL_DTYPE,NPRCIDS(ISEND)-1,ITAG,MPL_COMM_OML(OML_MY_THREAD()),IREQ(IR),IERROR)
    IR=IR+1
    CALL MPI_ISEND(ICOMBUFS_FLD(INS),1, &
    & MPI_INTEGER,NPRCIDS(ISEND)-1,ITAG,MPL_COMM_OML(OML_MY_THREAD()),IREQ(IR),IERROR)
  ENDDO
#ifdef OMPGPU
  !$OMP END TARGET DATA
#endif
#ifdef ACCGPU
  !$ACC END HOST_DATA
#endif
  
  IF(IR > 0) THEN
    CALL MPL_WAIT(KREQUEST=IREQ(1:IR), &
      & CDSTRING='TRGTOL_CUDAAWARE: WAIT FOR SENDS AND RECEIVES')
  ENDIF
  CALL GSTATS(413,1)
  
  !#ifdef COMVERBOSE
  !  call MPI_BARRIER(MPI_COMM_WORLD,IERROR)
  !  Tc=(TIMEF()-Tc)/1000.0_JPRBT
  !  !IF(irank==0) WRITE(*,*) "non-CUDA-aware isend/irecv (trgtol) in sec: ", Tc
  !#endif
  
  IF(.NOT.LGPNORM)THEN
    CALL GSTATS(803,1)
  ELSE
    CALL GSTATS(804,1)
  ENDIF
  CALL GSTATS_BARRIER2(761)
  
  !#ifdef COMVERBOSE
  !  call MPI_BARRIER(MPI_COMM_WORLD,IERROR)
  !  Tc=TIMEF()
  !#endif
  !  Unpack loop.........................................................
  
  CALL GSTATS(1603,0)


  DO INR=1,INRECV
      IRECV=JRECV(INR)
      ILEN = IRECVTOT(IRECV)/KF_FS
      IRECV_FLD_END   = ICOMBUFR_FLD(INR)
#ifdef OMPGPU
      !$OMP TARGET TEAMS DISTRIBUTE PARALLEL DO COLLAPSE(2) DEFAULT(NONE) PRIVATE(II) &
      !$OMP&   MAP(TO:IRECV,ILEN,IRECV_FLD_END) &
      !$OMP&   SHARED(IRECV_FLD_END,ILEN,KINDEX,INDOFF,IRECV,ZCOMBUFR,PGLAT,INR)
#endif
#ifdef ACCGPU
      !$ACC PARALLEL LOOP COLLAPSE(2) DEFAULT(NONE) PRIVATE(II) COPYIN(IRECV,ILEN,IRECV_FLD_END) &
      !$ACC& PRESENT(IRECV_FLD_END,ILEN,KINDEX,INDOFF,IRECV,ZCOMBUFR,PGLAT,INR)
#endif
      DO JFLD=1,IRECV_FLD_END
        DO JL=1,ILEN
          II = KINDEX(INDOFF(IRECV)+JL)
          PGLAT(JFLD,II) = ZCOMBUFR(JL+(JFLD-1)*ILEN,INR)
        ENDDO
      ENDDO
  ENDDO
#ifdef OMPGPU
  !$OMP END TARGET DATA
#endif
#ifdef ACCGPU
  !$ACC END DATA
#endif
  
  !#ifdef COMVERBOSE
  !  call MPI_BARRIER(MPI_COMM_WORLD,IERROR)
  !  Tc=(TIMEF()-Tc)/1000.0_JPRBT
  !  !IF(irank==0) WRITE(*,*) "unpacking (trgtol) in sec: ", Tc
  !#endif

  CALL GSTATS(1603,1)

#ifdef OMPGPU
   !$OMP END TARGET DATA  !! PRESENT(PGP3B)
   !$OMP END TARGET DATA  !! PRESENT(PGP3A)
   !$OMP END TARGET DATA  !! PRESENT(PGP2)
   !$OMP END TARGET DATA  !! PRESENT(PGPUV)
   !$OMP END TARGET DATA  !! PRESENT(PGP)
   !$OMP END TARGET DATA  !! PRESENT(PGLAT)
#endif
   
#ifdef OMPGPU
   !$OMP END TARGET DATA  !! ZCOMBUFS
   !$OMP END TARGET DATA  !! ZCOMBUFS
#endif

#ifdef ACCGPU
   !$ACC END DATA  !! PRESENT(PGP3B)
   !$ACC END DATA  !! PRESENT(PGP3A)
   !$ACC END DATA  !! PRESENT(PGP2)
   !$ACC END DATA  !! PRESENT(PGPUV)
   !$ACC END DATA  !! PRESENT(PGP)
   !$ACC END DATA  !! PRESENT(PGLAT)
#endif
   
#ifdef ACCGPU
   !$ACC END DATA  !! ZCOMBUFS
   !$ACC END DATA  !! ZCOMBUFS
#endif
  
  IF (IBUFLENS > 0) DEALLOCATE(ZCOMBUFS)
  IF (IBUFLENR > 0) DEALLOCATE(ZCOMBUFR)

  IF (LHOOK) CALL DR_HOOK('TRGTOL_CUDAAWARE',1,ZHOOK_HANDLE)
  
  END SUBROUTINE TRGTOL_CUDAAWARE
#endif

  SUBROUTINE TRGTOL(PGLAT,KF_FS,KF_GP,KF_SCALARS_G,KVSET,KPTRGP,&
   &PGP,PGPUV,PGP3A,PGP3B,PGP2)
  
  !**** *TRGTOL * - transposition of grid point data from column
  !                 structure to latitudinal. Reorganize data between
  !                 grid point calculations and direct Fourier Transform
  
  !     Purpose.
  !     --------
  
  
  !**   Interface.
  !     ----------
  !        *call* *trgtol(...)
  
  !        Explicit arguments :
  !        --------------------
  !           PGLAT    -  Latitudinal data ready for direct FFT (output)
  !           PGP    -  Blocked grid point data    (input)
  
  !        Implicit arguments :
  !        --------------------
  
  !     Method.
  !     -------
  !        See documentation
  
  !     Externals.
  !     ----------
  
  !     Reference.
  !     ----------
  !        ECMWF Research Department documentation of the IFS
  
  !     Author.
  !     -------
  !        MPP Group *ECMWF*
  
  !     Modifications.
  !     --------------
  !        Original: 95-10-01
  !        D.Dent  : 97-08-04   Reorganisation to allow
  !                             NPRTRV to differ from NPRGPEW
  !                : 98-06-17   add mailbox control logic (from TRLTOM)
  !        =99-03-29= Mats Hamrud and Deborah Salmond
  !                   JUMP in FFT's changed to 1
  !                   KINDEX introduced and ZCOMBUF not used for same PE
  !         01-11-23  Deborah Salmond and John Hague
  !                    LIMP_NOOLAP Option for non-overlapping message passing
  !                    and buffer packing
  !         01-12-18  Peter Towers
  !                   Improved vector performance of GTOL_PACK,GTOL_UNPACK
  !         03-04-02  G. Radnoti: call barrier always when nproc>1
  !         08-01-01  G.Mozdzynski: cleanup
  !         09-01-02  G.Mozdzynski: use non-blocking recv and send
  !     ------------------------------------------------------------------
  
  
  
  USE PARKIND_ECTRANS ,ONLY : JPIM     ,JPRB,  JPRBT
  USE YOMHOOK         ,ONLY : LHOOK,   DR_HOOK, JPHOOK
  
  USE MPL_MODULE      ,ONLY : MPL_RECV, MPL_SEND, MPL_WAIT, JP_NON_BLOCKING_STANDARD
  
  USE TPM_GEN         ,ONLY : NOUT
  USE TPM_DISTR       ,ONLY : D, NPRCIDS, NPRTRNS, MTAGGL,  &
       &                      MYSETV, MYSETW, MYPROC, NPROC
  USE TPM_TRANS       ,ONLY : LDIVGP, LGPNORM, LSCDERS, LUVDER, LVORGP, NGPBLKS
  
  USE INIGPTR_MOD     ,ONLY : INIGPTR
  USE PE2SET_MOD      ,ONLY : PE2SET
  !USE MYSENDSET_MOD
  !USE MYRECVSET_MOD
  USE ABORT_TRANS_MOD ,ONLY : ABORT_TRANS
  !
#ifdef ACCGPU
  USE MPI
#endif
  
  IMPLICIT NONE
  
#ifdef OMPGPU
  include 'mpif.h'
#endif
  
  REAL(KIND=JPRBT),INTENT(OUT)   :: PGLAT(:,:)
  INTEGER(KIND=JPIM),INTENT(IN) :: KVSET(:)
  INTEGER(KIND=JPIM),INTENT(IN) :: KF_FS,KF_GP
  INTEGER(KIND=JPIM),INTENT(IN) :: KF_SCALARS_G
  INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KPTRGP(:)
  REAL(KIND=JPRB),OPTIONAL,INTENT(IN)     :: PGP(:,:,:)
  REAL(KIND=JPRB),OPTIONAL,INTENT(IN)     :: PGPUV(:,:,:,:)
  REAL(KIND=JPRB),OPTIONAL,INTENT(IN)     :: PGP3A(:,:,:,:)
  REAL(KIND=JPRB),OPTIONAL,INTENT(IN)     :: PGP3B(:,:,:,:)
  REAL(KIND=JPRB),OPTIONAL,INTENT(IN)     :: PGP2(:,:,:)
  
  REAL(KIND=JPRBT),ALLOCATABLE :: ZCOMBUFS(:,:),ZCOMBUFR(:,:)
  REAL(KIND=JPRBT) :: ZDUM(2)
  
  INTEGER(KIND=JPIM) :: ISENT    (NPROC)
  INTEGER(KIND=JPIM) :: IRCVD    (NPROC)
  INTEGER(KIND=JPIM) :: ISENDTOT (NPROC)
  INTEGER(KIND=JPIM) :: IRECVTOT (NPROC)
  INTEGER(KIND=JPIM) :: IREQ     (NPROC*2)
  INTEGER(KIND=JPIM) :: JRECV    (NPROC)
  INTEGER(KIND=JPIM) :: JSEND    (NPROC)
  
  !     LOCAL INTEGER SCALARS
  INTEGER(KIND=JPIM) :: IFIRST, IFIRSTLAT, IGL, IGLL, ILAST,&
               &ILASTLAT, ILEN, JROC, IPOS, ISETA, &
               &ISETB, IRECV, IRECVSET, &
               &ISETV, ISEND, ISENDSET, ITAG, J, JBLK, JFLD, &
               &JGL, JK, JL, JLOOP, ISETW,  IFLD, &
               &II,INDOFFX,IBUFLENS,IBUFLENR,INRECV, IPROC,IFLDS, &
               &INSEND,INS,INR,IR, iunit, JKL, JK_MAX
  
  !     LOCAL LOGICAL SCALARS
  LOGICAL   :: LLPGPUV,LLPGP3A,LLPGP3B,LLPGP2,LLPGPONLY
  LOGICAL   :: LLUV(KF_GP),LLGP2(KF_GP),LLGP3A(KF_GP),LLGP3B(KF_GP)
  LOGICAL :: LLDONE, LLINDER
  INTEGER(KIND=JPIM) :: IUVLEVS(KF_GP),IUVPARS(KF_GP),IGP2PARS(KF_GP)
  INTEGER(KIND=JPIM) :: IGP3APARS(KF_GP),IGP3ALEVS(KF_GP),IGP3BPARS(KF_GP),IGP3BLEVS(KF_GP)
  INTEGER(KIND=JPIM) :: IUVPAR,IUVLEV,IGP2PAR,IGP3ALEV,IGP3APAR,IGP3BLEV,IGP3BPAR,IPAROFF
  INTEGER(KIND=JPIM) :: IOFF,IOFF1,IOFFNS,IOFFEW,J1,J2
  INTEGER(KIND=JPIM) :: KINDEX(D%NLENGTF),INDOFF(NPROC),IFLDOFF(MAX(KF_GP,KF_FS))
  INTEGER(KIND=JPIM) :: ISEND_FLD_TOTAL(NPROC),ISEND_FLD_START(NPROC),ISEND_FLD_END
  INTEGER(KIND=JPIM) :: IRECV_FLD_START,IRECV_FLD_END
  INTEGER(KIND=JPIM) :: INUMFLDS
  INTEGER(KIND=JPIM) :: IGPTRSEND(2,NGPBLKS,NPRTRNS)
  INTEGER(KIND=JPIM) :: IGPTRRECV(NPRTRNS)
  INTEGER(KIND=JPIM) :: IGPTROFF(NGPBLKS)
  !     INTEGER FUNCTIONS
  INTEGER(KIND=JPIM) :: IRECVCOUNT,ISENDCOUNT
  INTEGER(KIND=JPIM) :: IJPOS(NGPBLKS),IFLDA(KF_GP),JJ,JI,IFLDT
  REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
  REAL(KIND=JPHOOK) :: ZHOOK_HANDLE_BAR
  
  INTEGER(KIND=JPIM) :: IERROR, irank
  
  REAL(KIND=JPRBT) :: TIMEF, tc
  
  !     ------------------------------------------------------------------
  
  !*       0.    Some initializations
  !              --------------------
  
  IF (LHOOK) CALL DR_HOOK('TRGTOL',0,ZHOOK_HANDLE)
  
  iunit=300+myproc

  CALL GSTATS(1805,0)
  
  LLINDER = .FALSE.
  LLPGPUV = .FALSE.
  LLPGP3A = .FALSE.
  LLPGP3B = .FALSE.
  LLPGP2  = .FALSE.
  LLPGPONLY = .FALSE.
  IF(PRESENT(KPTRGP))  LLINDER = .TRUE.
  IF(PRESENT(PGP))     LLPGPONLY = .TRUE.
  IF(PRESENT(PGPUV))   LLPGPUV = .TRUE.
  IF(PRESENT(PGP3A))   LLPGP3A = .TRUE.
  IF(PRESENT(PGP3B))   LLPGP3B = .TRUE.
  IF(PRESENT(PGP2))    LLPGP2 = .TRUE.
  IUVPAR=0
  IUVLEV=0
  IOFF1=0
  IOFFNS=KF_SCALARS_G
  IOFFEW=2*KF_SCALARS_G
  LLUV(:) = .FALSE.
  IUVPARS(:) = -99
  IUVLEVS(:) = -99
  IF (LLPGPUV) THEN
    IOFF=0
    IUVLEV=UBOUND(PGPUV,2)
    IF(LVORGP) THEN
      IUVPAR=IUVPAR+1
      DO J=1,IUVLEV
        IUVLEVS(IOFF+J)=J
        IUVPARS(IOFF+J)=IUVPAR
        LLUV(IOFF+J)=.TRUE.
      ENDDO
      IOFF=IOFF+IUVLEV
    ENDIF
    IF(LDIVGP) THEN
      IUVPAR=IUVPAR+1
      DO J=1,IUVLEV
        IUVLEVS(IOFF+J)=J
        IUVPARS(IOFF+J)=IUVPAR
        LLUV(IOFF+J)=.TRUE.
      ENDDO
      IOFF=IOFF+IUVLEV
    ENDIF
    DO J=1,IUVLEV
      IUVLEVS(IOFF+J)=J
      IUVPARS(IOFF+J)=IUVPAR+1
      IUVLEVS(IOFF+J+IUVLEV)=J
      IUVPARS(IOFF+J+IUVLEV)=IUVPAR+2
    ENDDO
    IUVPAR=IUVPAR+2
    LLUV(IOFF+1:IOFF+2*IUVLEV)=.TRUE.
    IOFF=IOFF+2*IUVLEV
    IOFF1=IOFF
    IOFFNS=IOFFNS+IOFF
    IOFFEW=IOFFEW+IOFF
    IOFF=IUVPAR*IUVLEV+KF_SCALARS_G
    IF(LUVDER) THEN
      IF(LSCDERS) IOFF=IOFF+KF_SCALARS_G
      DO J=1,IUVLEV
        IUVLEVS(IOFF+J)=J
        IUVPARS(IOFF+J)=IUVPAR+1
        LLUV(IOFF+J)=.TRUE.
        IUVLEVS(IOFF+J+IUVLEV)=J
        IUVPARS(IOFF+J+IUVLEV)=IUVPAR+2
        LLUV(IOFF+J+IUVLEV)=.TRUE.
      ENDDO
      IUVPAR=IUVPAR+2
      IOFF=IOFF+2*IUVLEV
      IOFFEW=IOFFEW+2*IUVLEV
    ENDIF
  ENDIF
  LLGP2(:)=.FALSE.
  IF(LLPGP2) THEN
    IOFF=IOFF1
    IGP2PAR=UBOUND(PGP2,2)
    IF(LSCDERS) IGP2PAR=IGP2PAR/3
    DO J=1,IGP2PAR
      LLGP2(J+IOFF) = .TRUE.
      IGP2PARS(J+IOFF)=J
    ENDDO
    IOFF1=IOFF1+IGP2PAR
    IF(LSCDERS) THEN
      IOFF=IOFFNS
      DO J=1,IGP2PAR
        LLGP2(J+IOFF) = .TRUE.
        IGP2PARS(J+IOFF)=J+IGP2PAR
      ENDDO
      IOFFNS=IOFF+IGP2PAR
      IOFF=IOFFEW
      DO J=1,IGP2PAR
        LLGP2(J+IOFF) = .TRUE.
        IGP2PARS(J+IOFF)=J+2*IGP2PAR
      ENDDO
      IOFFEW=IOFF+IGP2PAR
    ENDIF
  ENDIF
  LLGP3A(:) = .FALSE.
  IF(LLPGP3A) THEN
    IGP3ALEV=UBOUND(PGP3A,2)
    IGP3APAR=UBOUND(PGP3A,3)
    IF(LSCDERS) IGP3APAR=IGP3APAR/3
    IOFF=IOFF1
    DO J1=1,IGP3APAR
      DO J2=1,IGP3ALEV
        LLGP3A(J2+(J1-1)*IGP3ALEV+IOFF) = .TRUE.
        IGP3APARS(J2+(J1-1)*IGP3ALEV+IOFF)=J1
        IGP3ALEVS(J2+(J1-1)*IGP3ALEV+IOFF)=J2
      ENDDO
    ENDDO
    IPAROFF=IGP3APAR
    IOFF1=IOFF1+IGP3APAR*IGP3ALEV
    IF(LSCDERS) THEN
      IOFF=IOFFNS
      DO J1=1,IGP3APAR
        DO J2=1,IGP3ALEV
          LLGP3A(J2+(J1-1)*IGP3ALEV+IOFF) = .TRUE.
          IGP3APARS(J2+(J1-1)*IGP3ALEV+IOFF)=J1+IPAROFF
          IGP3ALEVS(J2+(J1-1)*IGP3ALEV+IOFF)=J2
        ENDDO
      ENDDO
      IPAROFF=IPAROFF+IGP3APAR
      IOFFNS=IOFFNS+IGP3APAR*IGP3ALEV
      IOFF=IOFFEW
      DO J1=1,IGP3APAR
        DO J2=1,IGP3ALEV
          LLGP3A(J2+(J1-1)*IGP3ALEV+IOFF) = .TRUE.
          IGP3APARS(J2+(J1-1)*IGP3ALEV+IOFF)=J1+IPAROFF
          IGP3ALEVS(J2+(J1-1)*IGP3ALEV+IOFF)=J2
        ENDDO
      ENDDO
      IOFFEW=IOFFEW+IGP3APAR*IGP3ALEV
    ENDIF
  ENDIF
  LLGP3B(:) = .FALSE.
  IF(LLPGP3B) THEN
    IGP3BLEV=UBOUND(PGP3B,2)
    IGP3BPAR=UBOUND(PGP3B,3)
    IF(LSCDERS) IGP3BPAR=IGP3BPAR/3
    IOFF=IOFF1
    DO J1=1,IGP3BPAR
      DO J2=1,IGP3BLEV
        LLGP3B(J2+(J1-1)*IGP3BLEV+IOFF) = .TRUE.
        IGP3BPARS(J2+(J1-1)*IGP3BLEV+IOFF)=J1
        IGP3BLEVS(J2+(J1-1)*IGP3BLEV+IOFF)=J2
      ENDDO
    ENDDO
    IPAROFF=IGP3BPAR
    IOFF1=IOFF1+IGP3BPAR*IGP3BLEV
    IF(LSCDERS) THEN
      IOFF=IOFFNS
      DO J1=1,IGP3BPAR
        DO J2=1,IGP3BLEV
          LLGP3B(J2+(J1-1)*IGP3BLEV+IOFF) = .TRUE.
          IGP3BPARS(J2+(J1-1)*IGP3BLEV+IOFF)=J1+IPAROFF
          IGP3BLEVS(J2+(J1-1)*IGP3BLEV+IOFF)=J2
        ENDDO
      ENDDO
      IPAROFF=IPAROFF+IGP3BPAR
      IOFFNS=IOFFNS+IGP3BPAR*IGP3BLEV
      IOFF=IOFFEW
      DO J1=1,IGP3BPAR
        DO J2=1,IGP3BLEV
          LLGP3B(J2+(J1-1)*IGP3BLEV+IOFF) = .TRUE.
          IGP3BPARS(J2+(J1-1)*IGP3BLEV+IOFF)=J1+IPAROFF
          IGP3BLEVS(J2+(J1-1)*IGP3BLEV+IOFF)=J2
        ENDDO
      ENDDO
      IOFFEW=IOFFEW+IGP3BPAR*IGP3BLEV
    ENDIF
  ENDIF
  
  
  CALL INIGPTR(IGPTRSEND,IGPTRRECV)
  LLDONE = .FALSE.
  
  ITAG = MTAGGL
  
  INDOFFX  = 0
  IBUFLENS = 0
  IBUFLENR = 0
  INRECV   = 0
  INSEND   = 0
  
  DO JROC=1,NPROC
  
    CALL PE2SET(JROC,ISETA,ISETB,ISETW,ISETV)
    IRECVSET = ISETA
    ISEND = JROC
    ISENDSET = ISETV
    ISENT(JROC) = 0
    IRCVD(JROC) = 0
  
  !             count up expected number of fields
    IPOS = 0
    DO JFLD=1,KF_GP
      IF(KVSET(JFLD) == ISENDSET .OR. KVSET(JFLD) == -1) IPOS = IPOS+1
    ENDDO
    ISEND_FLD_TOTAL(JROC) = IPOS
    ISENDTOT(JROC) = IGPTRRECV(ISETW)*IPOS
  
    IF( JROC /= MYPROC) THEN
      IBUFLENS = MAX(IBUFLENS,ISENDTOT(JROC))
      IF(ISENDTOT(JROC) > 0) THEN
        INSEND = INSEND+1
        JSEND(INSEND)=JROC
      ENDIF
    ENDIF
  
    IFIRSTLAT = MAX(D%NPTRLS(MYSETW),D%NFRSTLAT(IRECVSET))
    ILASTLAT  = MIN(D%NPTRLS(MYSETW)+D%NULTPP(MYSETW)-1,D%NLSTLAT(IRECVSET))
  
    IPOS = 0
    DO JGL=IFIRSTLAT,ILASTLAT
      IGL  = D%NPTRFRSTLAT(IRECVSET)+JGL-D%NFRSTLAT(IRECVSET)
      IPOS = IPOS+D%NONL(IGL,ISETB)
    ENDDO
  
    IRECVTOT(JROC) = IPOS*KF_FS
  
    IF(IRECVTOT(JROC) > 0 .AND. MYPROC /= JROC) THEN
      INRECV = INRECV + 1
      JRECV(INRECV)=JROC
    ENDIF
  
    IF( JROC /= MYPROC) IBUFLENR = MAX(IBUFLENR,IRECVTOT(JROC))
  
    IF(IPOS > 0) THEN
      INDOFF(JROC) = INDOFFX
      INDOFFX = INDOFFX+IPOS
      IPOS = 0
      DO JGL=IFIRSTLAT,ILASTLAT
        IGL  = D%NPTRFRSTLAT(IRECVSET)+JGL-D%NFRSTLAT(IRECVSET)
        IGLL = JGL-D%NPTRLS(MYSETW)+1
        DO JL=D%NSTA(IGL,ISETB)+D%NSTAGTF(IGLL),&
         &D%NSTA(IGL,ISETB)+D%NSTAGTF(IGLL)+D%NONL(IGL,ISETB)-1
          IPOS = IPOS+1
          KINDEX(IPOS+INDOFF(JROC)) = JL
        ENDDO
      ENDDO
    ENDIF
  
  ENDDO
  
  ISENDCOUNT=0
  IRECVCOUNT=0
  DO J=1,NPROC
    ISENDCOUNT=MAX(ISENDCOUNT,ISENDTOT(J))
    IRECVCOUNT=MAX(IRECVCOUNT,IRECVTOT(J))
  ENDDO
  IF (IBUFLENS > 0) ALLOCATE(ZCOMBUFS(-1:ISENDCOUNT,INSEND))
  IF (IBUFLENR > 0) ALLOCATE(ZCOMBUFR(-1:IRECVCOUNT,INRECV))

  CALL GSTATS(1805,1)
  
  ! Send loop.............................................................
  
  ! Copy local contribution

#ifdef ACCGPU
  !$ACC DATA PRESENT(PGLAT) COPYIN(KPTRGP,INDOFF,KINDEX)
  !$ACC DATA IF(PRESENT(PGP))   PRESENT(PGP)
  !$ACC DATA IF(PRESENT(PGPUV)) PRESENT(PGPUV) COPYIN(IUVLEVS,IUVPARS)
  !$ACC DATA IF(PRESENT(PGP2))  PRESENT(PGP2)  COPYIN(IGP2PARS)
  !$ACC DATA IF(PRESENT(PGP3A)) PRESENT(PGP3A) COPYIN(IGP3ALEVS,IGP3APARS)
  !WARNING: The following line should work but we see run time errors like:
  ! find_in_present_table failed for 'igp3blevs(:)' (0x7ffffff74d30-0x7ffffff753a0) ... src/trans/gpu/internal/trgtol_mod.F90:1326
  !!$ACC DATA IF(PRESENT(PGP3B)) PRESENT(PGP3B) COPYIN(IGP3BLEVS,IGP3BPARS)
  !$ACC DATA PRESENT(PGP3B) COPYIN(IGP3BLEVS,IGP3BPARS)
#endif
#ifdef OMPGPU
!WARNING: following lines should be PRESENT,ALLOC but cause issues with AMD compiler!
  !$OMP TARGET DATA MAP(ALLOC:PGLAT) MAP(TO:KPTRGP,INDOFF,KINDEX)
  !$OMP TARGET DATA IF(PRESENT(PGP))   MAP(ALLOC:PGP)
  !$OMP TARGET DATA IF(PRESENT(PGPUV)) MAP(ALLOC:PGPUV) MAP(TO:IUVLEVS,IUVPARS)
  !$OMP TARGET DATA IF(PRESENT(PGP2))  MAP(ALLOC:PGP2)  MAP(TO:IGP2PARS)
  !$OMP TARGET DATA IF(PRESENT(PGP3A)) MAP(ALLOC:PGP3A) MAP(TO:IGP3ALEVS,IGP3APARS)
  !$OMP TARGET DATA IF(PRESENT(PGP3B)) MAP(ALLOC:PGP3B) MAP(TO:IGP3BLEVS,IGP3BPARS)
#endif

  IF(ISENDTOT(MYPROC) > 0 )THEN
    IFLDS = 0
    DO JFLD=1,KF_GP
      IF(KVSET(JFLD) == MYSETV .OR. KVSET(JFLD) == -1) THEN
        IFLDS = IFLDS+1
        IF(LLINDER) THEN
          IFLDOFF(IFLDS) = KPTRGP(JFLD)
        ELSE
          IFLDOFF(IFLDS) = JFLD
        ENDIF
      ENDIF
    ENDDO
  
    IPOS=0
    JK_MAX = 0
    DO JBLK=1,NGPBLKS
      IGPTROFF(JBLK)=IPOS
      IFIRST = IGPTRSEND(1,JBLK,MYSETW)
      IF(IFIRST > 0) THEN
        ILAST = IGPTRSEND(2,JBLK,MYSETW)
        IPOS=IPOS+ILAST-IFIRST+1
        IF (JK_MAX<(ILAST-IFIRST+1)) JK_MAX = (ILAST-IFIRST+1)
      ENDIF
    ENDDO
#ifdef ACCGPU
    !$ACC DATA COPYIN(IFLDOFF,IGPTROFF,LLGP2,LLGP3A,LLGP3B,LLUV,IGPTRSEND)
#endif
#ifdef OMPGPU
    !$OMP TARGET DATA MAP(TO:IFLDOFF,IGPTROFF,LLGP2,LLGP3A,LLGP3B,LLUV,IGPTRSEND)
#endif
    CALL GSTATS(1601,0)
    IF(LLPGPONLY) THEN
#ifdef OMPGPU
      !$OMP TARGET TEAMS DISTRIBUTE PARALLEL DO COLLAPSE(3) DEFAULT(NONE) PRIVATE(IPOS,IFIRST,ILAST,IFLD,JK) &
      !$OMP& SHARED(NGPBLKS,IFLDS,JK_MAX,IGPTRSEND,MYSETW,INDOFF,MYPROC,IGPTROFF,IFLDOFF,KINDEX,PGLAT,PGP)
#endif
#ifdef ACCGPU
      !$ACC PARALLEL LOOP COLLAPSE(3) DEFAULT(NONE) PRIVATE(IPOS,IFIRST,ILAST,IFLD,JK) &
      !$ACC& PRESENT(NGPBLKS,IFLDS,JK_MAX,IGPTRSEND,MYSETW,INDOFF,MYPROC,IGPTROFF,IFLDOFF,KINDEX,PGLAT,PGP)
#endif
      DO JBLK=1,NGPBLKS
        DO JFLD=1,IFLDS
          DO JKL=1, JK_MAX
            IFIRST = IGPTRSEND(1,JBLK,MYSETW)
            ILAST = IGPTRSEND(2,JBLK,MYSETW)
            JK = JKL+IFIRST-1
            IF(IFIRST > 0 .AND. JK <= ILAST) THEN
              IPOS = INDOFF(MYPROC)+IGPTROFF(JBLK)+JK-IFIRST+1
              IFLD = IFLDOFF(JFLD)
              PGLAT(JFLD,KINDEX(IPOS)) = PGP(JK,IFLD,JBLK)
            ENDIF
          ENDDO
        ENDDO
     ENDDO
#ifdef OMPGPU
     !$OMP END TARGET TEAMS DISTRIBUTE PARALLEL DO
#endif
    ELSE
#ifdef OMPGPU
      !$OMP TARGET TEAMS DISTRIBUTE PARALLEL DO COLLAPSE(3) DEFAULT(NONE) PRIVATE(IPOS,IFIRST,ILAST,IFLD,JK) &
      !$OMP& SHARED(NGPBLKS,IFLDS,JK_MAX,IGPTRSEND,MYSETW,INDOFF,MYPROC,IGPTROFF,IFLDOFF, &
      !$OMP&        LLUV,LLGP2,LLGP3A,LLGP3B,PGLAT,KINDEX,PGPUV,PGP2,PGP3A,PGP3B,IUVLEVS, &
      !$OMP&        IUVPARS,IGP2PARS,IGP3ALEVS,IGP3APARS,IGP3BLEVS,IGP3BPARS)
#endif
#ifdef ACCGPU
      !$ACC PARALLEL LOOP COLLAPSE(3) DEFAULT(NONE) PRIVATE(IPOS,IFIRST,ILAST,IFLD,JK) &
      !$ACC& COPYIN(NGPBLKS,IFLDS,JK_MAX,MYSETW,MYPROC) &
      !$ACC& PRESENT(NGPBLKS,IFLDS,JK_MAX,IGPTRSEND,MYSETW,INDOFF,MYPROC,IGPTROFF,IFLDOFF, &
      !$ACC&         LLUV,LLGP2,LLGP3A,LLGP3B,PGLAT,KINDEX,PGPUV,PGP2,PGP3A,PGP3B,IUVLEVS, &
      !$ACC&         IUVPARS,IGP2PARS,IGP3ALEVS,IGP3APARS,IGP3BLEVS,IGP3BPARS)
#endif
      DO JBLK=1,NGPBLKS
        DO JFLD=1,IFLDS
          DO JKL=1, JK_MAX
            IFIRST = IGPTRSEND(1,JBLK,MYSETW)
            ILAST = IGPTRSEND(2,JBLK,MYSETW)
            JK = JKL+IFIRST-1
            IF(IFIRST > 0 .AND. JK <= ILAST) THEN
              IPOS = INDOFF(MYPROC)+IGPTROFF(JBLK)+JK-IFIRST+1
              IFLD = IFLDOFF(JFLD)
              IF(LLUV(IFLD)) THEN
                PGLAT(JFLD,KINDEX(IPOS)) = PGPUV(JK,IUVLEVS(IFLD),IUVPARS(IFLD),JBLK)
              ELSEIF(LLGP2(IFLD)) THEN
                PGLAT(JFLD,KINDEX(IPOS)) = PGP2(JK,IGP2PARS(IFLD),JBLK)
              ELSEIF(LLGP3A(IFLD)) THEN
                PGLAT(JFLD,KINDEX(IPOS)) = PGP3A(JK,IGP3ALEVS(IFLD),IGP3APARS(IFLD),JBLK)
              ELSEIF(LLGP3B(IFLD)) THEN
                PGLAT(JFLD,KINDEX(IPOS)) = PGP3B(JK,IGP3BLEVS(IFLD),IGP3BPARS(IFLD),JBLK)
              ENDIF
            ENDIF
          ENDDO
        ENDDO
      ENDDO
#ifdef OMPGPU
      !$OMP END TARGET TEAMS DISTRIBUTE PARALLEL DO
#endif
    ENDIF
#ifdef ACCGPU
    !$ACC END DATA  !! IFLDOFF,IGPTROFF,LLGP2,LLGP3A,LLGP3B,LLUV,IGPTRSEND
#endif
#ifdef OMPGPU
    !$OMP END TARGET DATA !! IFLDOFF,IGPTROFF,LLGP2,LLGP3A,LLGP3B,LLUV,IGPTRSEND
#endif
    CALL GSTATS(1601,1)
  ENDIF
#ifdef ACCGPU
  !$ACC END DATA  !! PRESENT(PGP3B)
  !$ACC END DATA  !! PRESENT(PGP3A)
  !$ACC END DATA  !! PRESENT(PGP2)
  !$ACC END DATA  !! PRESENT(PGPUV)
  !$ACC END DATA  !! PRESENT(PGP)
#endif
#ifdef OMPGPU
  !$OMP END TARGET DATA  !! PRESENT(PGP3B)
  !$OMP END TARGET DATA  !! PRESENT(PGP3A)
  !$OMP END TARGET DATA  !! PRESENT(PGP2)
  !$OMP END TARGET DATA  !! PRESENT(PGPUV)
  !$OMP END TARGET DATA  !! PRESENT(PGP)
#endif

#ifdef COMVERBOSE
    call MPI_BARRIER(MPI_COMM_WORLD,IERROR)
    Tc=TIMEF()
#endif
  !....Pack loop.........................................................
  
  ISEND_FLD_START=1
  CALL GSTATS(1602,0)
  !$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(IFLDT,JBLK,IFIRST,ILAST,JK,JJ,JI,&
  !$OMP& INS,ISEND,ISETA,ISETB,ISETW,ISETV,ISENDSET,ISEND_FLD_END,IFLD,IPOS,&
  !$OMP& IFLDA,JFLD,IJPOS)
    DO INS=1,INSEND
      ISEND=JSEND(INS)
      CALL PE2SET(ISEND,ISETA,ISETB,ISETW,ISETV)
      ISENDSET = ISETV
      ISEND_FLD_END = ISEND_FLD_TOTAL(ISEND)
      IFLD = 0
      IPOS = 0
      DO JFLD=1,KF_GP
        IF(KVSET(JFLD) == ISENDSET .OR. KVSET(JFLD) == -1 ) THEN
          IFLD = IFLD+1
          IFLDA(IFLD)=JFLD
        ENDIF
      ENDDO
  
      DO JBLK=1,NGPBLKS
        IFIRST = IGPTRSEND(1,JBLK,ISETW)
        IF(IFIRST > 0) THEN
          ILAST = IGPTRSEND(2,JBLK,ISETW)
          IJPOS(JBLK)=IPOS
          IPOS=IPOS+(ILAST-IFIRST+1)
        ENDIF
      ENDDO
  
  
      DO JJ=ISEND_FLD_START(ISEND),ISEND_FLD_END
        IFLDT=IFLDA(JJ)
        DO JBLK=1,NGPBLKS
          IFIRST = IGPTRSEND(1,JBLK,ISETW)
          IF(IFIRST > 0) THEN
            ILAST = IGPTRSEND(2,JBLK,ISETW)
            IF(LLINDER) THEN
              DO JK=IFIRST,ILAST
                JI=(JJ-ISEND_FLD_START(ISEND))*IPOS+IJPOS(JBLK)+JK-IFIRST+1
                ZCOMBUFS(JI,INS) = PGP(JK,KPTRGP(IFLDT),JBLK)
              ENDDO
            ELSE
              IF(LLPGPONLY) THEN
                DO JK=IFIRST,ILAST
                  JI=(JJ-ISEND_FLD_START(ISEND))*IPOS+IJPOS(JBLK)+JK-IFIRST+1
                  ZCOMBUFS(JI,INS) = PGP(JK,IFLDT,JBLK)
                ENDDO
              ELSEIF(LLUV(IFLDT)) THEN
                DO JK=IFIRST,ILAST
                  JI=(JJ-ISEND_FLD_START(ISEND))*IPOS+IJPOS(JBLK)+JK-IFIRST+1
                  ZCOMBUFS(JI,INS) = PGPUV(JK,IUVLEVS(IFLDT),IUVPARS(IFLDT),JBLK)
                ENDDO
              ELSEIF(LLGP2(IFLDT)) THEN
                DO JK=IFIRST,ILAST
                  JI=(JJ-ISEND_FLD_START(ISEND))*IPOS+IJPOS(JBLK)+JK-IFIRST+1
                  ZCOMBUFS(JI,INS) = PGP2(JK,IGP2PARS(IFLDT),JBLK)
                ENDDO
              ELSEIF(LLGP3A(IFLDT)) THEN
                DO JK=IFIRST,ILAST
                  JI=(JJ-ISEND_FLD_START(ISEND))*IPOS+IJPOS(JBLK)+JK-IFIRST+1
                  ZCOMBUFS(JI,INS) = PGP3A(JK,IGP3ALEVS(IFLDT),IGP3APARS(IFLDT),JBLK)
                ENDDO
              ELSEIF(LLGP3B(IFLDT)) THEN
                DO JK=IFIRST,ILAST
                  JI=(JJ-ISEND_FLD_START(ISEND))*IPOS+IJPOS(JBLK)+JK-IFIRST+1
                  ZCOMBUFS(JI,INS) = PGP3B(JK,IGP3BLEVS(IFLDT),IGP3BPARS(IFLDT),JBLK)
                ENDDO
              ENDIF
            ENDIF
          ENDIF
        ENDDO
      ENDDO
  
      IPOS=(ISEND_FLD_END-ISEND_FLD_START(ISEND)+1)*IPOS
      ZCOMBUFS(-1,INS) = 1
      ZCOMBUFS(0,INS) = IFLD
    ENDDO
  !$OMP END PARALLEL DO
#ifdef COMVERBOSE
    call MPI_BARRIER(MPI_COMM_WORLD,IERROR)
    Tc=(TIMEF()-Tc)/1000.0_JPRBT
    CALL MPI_COMM_RANK(MPI_COMM_WORLD, IRANK, IERROR)
    !IF(irank==0) WRITE(*,*) "packing (trgtol) in sec: ", Tc
#endif
  
  CALL GSTATS(1602,1)
  
  IF (LHOOK) CALL DR_HOOK('TRGTOL_BAR',0,ZHOOK_HANDLE_BAR)
  CALL GSTATS_BARRIER(761)
  IF (LHOOK) CALL DR_HOOK('TRGTOL_BAR',1,ZHOOK_HANDLE_BAR)
  
  IF(.NOT.LGPNORM)THEN
    CALL GSTATS(803,0)
  ELSE
    CALL GSTATS(804,0)
  ENDIF
  IR=0
  
#ifdef COMVERBOSE
    call MPI_BARRIER(MPI_COMM_WORLD,IERROR)
    Tc=TIMEF()
#endif

  !  Receive loop.........................................................
  DO INR=1,INRECV
    IR=IR+1
    IRECV=JRECV(INR)
    CALL MPL_RECV(ZCOMBUFR(-1:IRECVTOT(IRECV),INR), &
      & KSOURCE=NPRCIDS(IRECV), &
      & KMP_TYPE=JP_NON_BLOCKING_STANDARD,KREQUEST=IREQ(IR), &
      & KTAG=ITAG,CDSTRING='TRLTOG:' )
  !print*,irank,size(ZCOMBUFR(-1:IRECVTOT(IRECV),INR))
  ENDDO
  
  !....Send loop.........................................................
  DO INS=1,INSEND
    IR=IR+1
    ISEND=JSEND(INS)
    CALL MPL_SEND(ZCOMBUFS(-1:ISENDTOT(ISEND),INS),KDEST=NPRCIDS(ISEND), &
     & KMP_TYPE=JP_NON_BLOCKING_STANDARD,KREQUEST=IREQ(IR), &
     & KTAG=ITAG,CDSTRING='TRGTOL:' )
  ENDDO
  
  IF(IR > 0) THEN
    CALL MPL_WAIT(KREQUEST=IREQ(1:IR), &
      & CDSTRING='TRGTOL: WAIT FOR SENDS AND RECEIVES')
  ENDIF
  
  !#ifdef COMVERBOSE
  !  call MPI_BARRIER(MPI_COMM_WORLD,IERROR)
  !  Tc=(TIMEF()-Tc)/1000.0_JPRBT
  !  !IF(irank==0) WRITE(*,*) "non-CUDA-aware isend/irecv (trgtol) in sec: ", Tc
  !#endif
  
  IF(.NOT.LGPNORM)THEN
    CALL GSTATS(803,1)
  ELSE
    CALL GSTATS(804,1)
  ENDIF
  CALL GSTATS_BARRIER2(761)
  
  !#ifdef COMVERBOSE
  !  call MPI_BARRIER(MPI_COMM_WORLD,IERROR)
  !  Tc=TIMEF()
  !#endif
  !  Unpack loop.........................................................
  
  CALL GSTATS(1603,0)

#ifdef OMPGPU
  !$OMP TARGET DATA MAP(TO:ZCOMBUFR)
#endif
#ifdef ACCGPU
  !$ACC DATA COPYIN(ZCOMBUFR)
#endif
  DO INR=1,INRECV
      IRECV=JRECV(INR)
      ILEN = IRECVTOT(IRECV)/KF_FS
      IRECV_FLD_START = ZCOMBUFR(-1,INR)
      IRECV_FLD_END   = ZCOMBUFR(0,INR)
#ifdef OMPGPU
      !$OMP TARGET TEAMS DISTRIBUTE PARALLEL DO COLLAPSE(2) DEFAULT(NONE) PRIVATE(II) &
      !$OMP& SHARED(IRECV,ILEN,IRECV_FLD_START,IRECV_FLD_END,KINDEX,INDOFF,ZCOMBUFR,PGLAT,INR)
#endif
#ifdef ACCGPU
      !$ACC PARALLEL LOOP COLLAPSE(2) DEFAULT(NONE) PRIVATE(II) &
      !$ACC& COPYIN(IRECV,ILEN,IRECV_FLD_START,IRECV_FLD_END,INR) &
      !$ACC& PRESENT(KINDEX,INDOFF,ZCOMBUFR,PGLAT)
#endif
      DO JFLD=IRECV_FLD_START,IRECV_FLD_END
        DO JL=1,ILEN
          II = KINDEX(INDOFF(IRECV)+JL)
          PGLAT(JFLD,II) = ZCOMBUFR(JL+(JFLD-IRECV_FLD_START)*ILEN,INR)
        ENDDO
     ENDDO
#ifdef OMPGPU
     !$OMP END TARGET TEAMS DISTRIBUTE PARALLEL DO
#endif
   ENDDO
#ifdef OMPGPU
  !$OMP END TARGET DATA  !! ZCOMBUFR
  !$OMP END TARGET DATA  !! PGLAT INDOFF KINDEX KPTRGP
#endif
#ifdef ACCGPU
  !$ACC END DATA !! ZCOMBUFR
  !$ACC END DATA !! PGLAT INDOFF KINDEX KPTRGP
#endif

  ! this appears to be important (otherwise, old data picked in PGLAT)
  ! in particular, one would have thought that above ACC copy and update on the
  ! device is the same as OMP loop + update device command below, but it seems not, and winds still in field index 1 from prev inv_trans !!!

!$OMP BARRIER
! when run as gpnorm on cpu needs to avoid this update call
IF(.NOT.LGPNORM) THEN
#ifdef ACCGPU
!! All data is updated on device already. PJM 9/05/2023
!  !$ACC UPDATE DEVICE(PGLAT)
#endif
#ifdef ACCGPU
!! I don't understand the need for this. PJM 9/05/2023
!  !$ACC WAIT
#endif
ENDIF
  
  !#ifdef COMVERBOSE
  !  call MPI_BARRIER(MPI_COMM_WORLD,IERROR)
  !  Tc=(TIMEF()-Tc)/1000.0_JPRBT
  !  !IF(irank==0) WRITE(*,*) "unpacking (trgtol) in sec: ", Tc
  !#endif

  CALL GSTATS(1603,1)
 
  IF (IBUFLENS > 0) DEALLOCATE(ZCOMBUFS)
  IF (IBUFLENR > 0) DEALLOCATE(ZCOMBUFR)

  IF (LHOOK) CALL DR_HOOK('TRGTOL',1,ZHOOK_HANDLE)

  END SUBROUTINE TRGTOL
  END MODULE TRGTOL_MOD

