! (C) Copyright 2000- ECMWF.
! (C) Copyright 2000- Meteo-France.
! 
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.
!

MODULE DIST_GRID_CTL_MOD
CONTAINS
SUBROUTINE DIST_GRID_CTL(PGPG,KFDISTG,KPROMA,KFROM,KFLDS,PGP,KSORT)

!**** *DIST_GRID_CTL* - Distributing global gridpoint array to processors

!     Purpose.
!     --------
!        Routine for distributing gridpoint array

!**   Interface.
!     ----------
!     CALL DIST_GRID_CTL(...)

!     Explicit arguments :
!     --------------------
!     PGPG(:,:)   - Global gridpoint array
!     KFDISTG     - Number of fields in this task to be distributed among all tasks
!     KPROMA      - required blocking factor for gridpoint output
!     KFROM(:)    - Processor responsible for distributing each field
!     KFLDS       - Number of fields in output distributed arrays
!     PGP(:,:,:)  - Local gridpoint array
!     KSORT(:)    - Add KSORT

!     Externals.  SET2PE - compute "A and B" set from PE
!     ----------  MPL..  - message passing routines

!     Author.
!     -------
!        Mats Hamrud *ECMWF*

!     Modifications.
!     --------------
!        Original : 2000-04-01
!    P.Marguinaud : 2014-10-10
!    R. El khatib 19-Jun-2019 Optimize by overlapping communications with pack/unpack and making less but larger messages.
!    R. El khatib 13-Jun-2022 Reduce pressure on the stack and/or fix a lost optimization
!     ------------------------------------------------------------------

USE PARKIND1  ,ONLY : JPIM     ,JPRB
USE MPL_MODULE  ,ONLY : MPL_RECV, MPL_SEND, MPL_BARRIER, MPL_WAIT, JP_NON_BLOCKING_STANDARD, MPL_WAITANY

USE TPM_DISTR       ,ONLY : D, MTAGDISTGP, NPRCIDS, MYPROC, NPROC
USE TPM_GEOMETRY    ,ONLY : G

USE SET2PE_MOD      ,ONLY : SET2PE
USE PE2SET_MOD      ,ONLY : PE2SET
USE ABORT_TRANS_MOD ,ONLY : ABORT_TRANS
USE EQ_REGIONS_MOD  ,ONLY : N_REGIONS, N_REGIONS_NS
!

IMPLICIT NONE

! Declaration of arguments

INTEGER(KIND=JPIM)          , INTENT(IN)  :: KFDISTG
REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN)  :: PGPG(D%NGPTOTG,KFDISTG)
INTEGER(KIND=JPIM)          , INTENT(IN)  :: KPROMA
INTEGER(KIND=JPIM)          , INTENT(IN)  :: KFROM(KFDISTG)
INTEGER(KIND=JPIM)          , INTENT(IN)  :: KFLDS
REAL(KIND=JPRB)             , INTENT(OUT) :: PGP(KPROMA,KFLDS,(D%NGPTOT-1)/KPROMA+1) 
INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN), TARGET :: KSORT (:)

! Declaration of local variables


REAL(KIND=JPRB),ALLOCATABLE :: ZRCV(:,:) ! (D%NGPTOTMX,KFDISTG)
REAL(KIND=JPRB),ALLOCATABLE :: ZBUF(:,:,:)
REAL(KIND=JPRB)    :: ZGP(D%NGPTOT)
INTEGER(KIND=JPIM) :: JFLD,JB,JA,IGLOFF,IGL1,IGL2,IOFF,ILAST, JGL,JLON,ITO,ITAG,J,IRCV, JROC, ILOCFLD, IGPBLKS
INTEGER(KIND=JPIM) :: JKGLO,IEND,JROF,IBL, IW,IV, IS, IR, JR, INR, IFLDCOUNT, IFLDLOC(KFDISTG)
INTEGER(KIND=JPIM) :: ISENDREQ(NPROC), IPROC(NPROC), IRCVREQ(NPROC), IOFFPROC(NPROC)
INTEGER(KIND=JPIM), ALLOCATABLE :: IOFFGP(:), IOFFA(:), ILONA(:)
INTEGER(KIND=JPIM), POINTER :: ISORT (:)

!     ------------------------------------------------------------------

IF (PRESENT (KSORT)) THEN
  ISORT => KSORT
ELSE
  ALLOCATE (ISORT (KFDISTG))
  DO JFLD = 1, KFDISTG
    ISORT (JFLD) = JFLD
  ENDDO
ENDIF

ALLOCATE(IOFFGP(MINVAL(D%NFRSTLAT(:)):MAXVAL(D%NLSTLAT(:))))
ALLOCATE(IOFFA(MINVAL(D%NFRSTLAT(:)):MAXVAL(D%NLSTLAT(:))))
ALLOCATE(ILONA(MINVAL(D%NFRSTLAT(:)):MAXVAL(D%NLSTLAT(:))))

ALLOCATE(ZRCV(D%NGPTOTMX,KFDISTG))

IR=0
! Post receives
IOFFPROC(1)=0
DO JROC=1,NPROC
  IF (JROC /= MYPROC) THEN
    IF (ANY(KFROM(1:KFDISTG) == JROC)) THEN
      ITAG = MTAGDISTGP
      IR=IR+1
      CALL GSTATS(811,0)
      CALL MPL_RECV(ZRCV(:,IOFFPROC(IR)+1:IOFFPROC(IR)+COUNT(KFROM(1:KFDISTG) == JROC)),&
       & KMP_TYPE=JP_NON_BLOCKING_STANDARD,KREQUEST=IRCVREQ(IR), &
       & KSOURCE=NPRCIDS(JROC),KTAG=ITAG,CDSTRING='DIST_GRID_CTL:')
      CALL GSTATS(811,1)
      IPROC(IR)=JROC
      IOFFPROC(IR+1)=IOFFPROC(IR)+COUNT(KFROM(1:KFDISTG) == JROC)
    ENDIF
  ENDIF
ENDDO

! Fill and send
ALLOCATE (ZBUF(D%NGPTOTMX,COUNT(KFROM(:) == MYPROC),NPROC))
IF (SIZE(ZBUF) > 0) THEN
  ! Force allocation right here, not inside the open-mp region below :
  ZBUF(1,1,1)=HUGE(1._JPRB)
ENDIF
IS=0
IFLDCOUNT=0
DO JFLD=1,KFDISTG
  IF(KFROM(JFLD) == MYPROC) THEN
    IFLDCOUNT = IFLDCOUNT+1
    IFLDLOC(IFLDCOUNT)=JFLD
  ENDIF
ENDDO
IF(IFLDCOUNT > 0) THEN
  DO JA=1,N_REGIONS_NS
    IGLOFF = D%NPTRFRSTLAT(JA)
    IGL1   = D%NFRSTLAT(JA)
    IGL2   = D%NLSTLAT(JA)
    DO JB=1,N_REGIONS(JA)
      CALL SET2PE(ITO,JA,JB,0,0)
      IF (ITO /= MYPROC) THEN
        IF(JA == 1) THEN
          IOFF = 0
        ELSE
          IF( D%NLSTLAT(JA-1) == D%NFRSTLAT(JA) )THEN
            IOFF = SUM(G%NLOEN(D%NFRSTLAT(1):D%NLSTLAT(JA-1)-1))
          ELSE
            IOFF = SUM(G%NLOEN(D%NFRSTLAT(1):D%NLSTLAT(JA-1)))
          ENDIF
        ENDIF
        IOFFGP(IGL1) = 0
        IOFFA(IGL1)=IOFF+D%NSTA(IGLOFF,JB)
        DO JGL=IGL1,IGL2-1
          ILONA(JGL)=D%NONL(IGLOFF+JGL-IGL1,JB)
          IOFFGP(JGL+1) = SUM(D%NONL(IGLOFF:IGLOFF+JGL-IGL1,JB))
          IOFFA(JGL+1)=IOFF+SUM(G%NLOEN(IGL1:JGL))+D%NSTA(IGLOFF+JGL-IGL1+1,JB)
        ENDDO
        ILONA(IGL2)=D%NONL(IGLOFF+IGL2-IGL1,JB)
        CALL GSTATS(1663,0)
!$OMP PARALLEL PRIVATE(JFLD,JGL)
        IF (IFLDCOUNT > IGL2-IGL1+1) THEN
!$OMP DO SCHEDULE(STATIC)
          DO JFLD=1,IFLDCOUNT
            DO JGL=IGL1,IGL2
              ZBUF(IOFFGP(JGL)+1:IOFFGP(JGL)+ILONA(JGL),JFLD,ITO) = PGPG(IOFFA(JGL):IOFFA(JGL)+ILONA(JGL)-1,JFLD)
            ENDDO
          ENDDO
!$OMP END DO
        ELSE
!$OMP DO SCHEDULE(STATIC)
          DO JGL=IGL1,IGL2
            DO JFLD=1,IFLDCOUNT
              ZBUF(IOFFGP(JGL)+1:IOFFGP(JGL)+ILONA(JGL),JFLD,ITO) = PGPG(IOFFA(JGL):IOFFA(JGL)+ILONA(JGL)-1,JFLD)
            ENDDO
          ENDDO
!$OMP END DO
        ENDIF
!$OMP END PARALLEL
        CALL GSTATS(1663,1)
        ITAG = MTAGDISTGP
        IS=IS+1
        CALL GSTATS(811,0)
        CALL MPL_SEND(ZBUF(:,:,ITO),KDEST=NPRCIDS(ITO),KTAG=ITAG,&
         &KMP_TYPE=JP_NON_BLOCKING_STANDARD,KREQUEST=ISENDREQ(IS),&
         &CDSTRING='DIST_GRID_CTL')
        CALL GSTATS(811,1)
      ENDIF
    ENDDO
  ENDDO
ENDIF
  
! Message passing
CALL GSTATS_BARRIER(791)

IGPBLKS = (D%NGPTOT-1)/KPROMA+1 

IF(IFLDCOUNT > 0) THEN
  ! Transfert for myself :
  CALL PE2SET(MYPROC,JA,JB,IW,IV)
  IGLOFF = D%NPTRFRSTLAT(JA)
  IGL1   = D%NFRSTLAT(JA)
  IGL2   = D%NLSTLAT(JA)
  IF(JA == 1) THEN
    IOFF = 0
  ELSE
    IF( D%NLSTLAT(JA-1) == D%NFRSTLAT(JA) )THEN
      IOFF = SUM(G%NLOEN(D%NFRSTLAT(1):D%NLSTLAT(JA-1)-1))
    ELSE
      IOFF = SUM(G%NLOEN(D%NFRSTLAT(1):D%NLSTLAT(JA-1)))
    ENDIF

  ENDIF
  IOFFGP(IGL1) = 0
  IOFFA(IGL1)=IOFF+D%NSTA(IGLOFF,JB)
  DO JGL=IGL1,IGL2-1
    ILONA(JGL)=D%NONL(IGLOFF+JGL-IGL1,JB)
    IOFFGP(JGL+1) = SUM(D%NONL(IGLOFF:IGLOFF+JGL-IGL1,JB))
    IOFFA(JGL+1)=IOFF+SUM(G%NLOEN(IGL1:JGL))+D%NSTA(IGLOFF+JGL-IGL1+1,JB)
  ENDDO
  ILONA(IGL2)=D%NONL(IGLOFF+IGL2-IGL1,JB)
  CALL GSTATS(1663,0)
  IF (IFLDCOUNT > IGPBLKS) THEN
!$OMP PARALLEL DO SCHEDULE(STATIC) PRIVATE(JFLD,JGL,JKGLO,IEND,IBL,ZGP,ILOCFLD)
    DO JFLD=1,IFLDCOUNT
      ILOCFLD=ISORT(IFLDLOC(JFLD))
      DO JGL=IGL1,IGL2
        ZGP(IOFFGP(JGL)+1:IOFFGP(JGL)+ILONA(JGL)) = PGPG(IOFFA(JGL):IOFFA(JGL)+ILONA(JGL)-1,JFLD)
      ENDDO
      DO JKGLO=1,D%NGPTOT,KPROMA
        IEND = MIN(KPROMA,D%NGPTOT-JKGLO+1)
        IBL  = (JKGLO-1)/KPROMA+1
        PGP(1:IEND,ILOCFLD,IBL) = ZGP(JKGLO:JKGLO+IEND-1)
      ENDDO
    ENDDO
!$OMP END PARALLEL DO
  ELSE
    DO JFLD=1,IFLDCOUNT
      ILOCFLD=ISORT(IFLDLOC(JFLD))
!$OMP PARALLEL PRIVATE(JGL,JKGLO,IEND,IBL)
!$OMP DO SCHEDULE(STATIC) 
      DO JGL=IGL1,IGL2
        ZGP(IOFFGP(JGL)+1:IOFFGP(JGL)+ILONA(JGL)) = PGPG(IOFFA(JGL):IOFFA(JGL)+ILONA(JGL)-1,JFLD)
      ENDDO
!$OMP END DO
!$OMP DO SCHEDULE(STATIC)
      DO JKGLO=1,D%NGPTOT,KPROMA
        IEND = MIN(KPROMA,D%NGPTOT-JKGLO+1)
        IBL  = (JKGLO-1)/KPROMA+1
        PGP(1:IEND,ILOCFLD,IBL) = ZGP(JKGLO:JKGLO+IEND-1)
      ENDDO
!$OMP END DO
!$OMP END PARALLEL
    ENDDO
  ENDIF
  CALL GSTATS(1663,1)

ENDIF

! Wait for recv to complete and fill
DO JR=1, IR
  CALL GSTATS(811,0)
  CALL MPL_WAITANY(KREQUEST=IRCVREQ(1:IR), KINDEX=INR, CDSTRING='DIST_GRID_CTL: WAIT FOR RECV')
  CALL GSTATS(811,1)
  CALL GSTATS(1663,0)
  IFLDCOUNT=0
  DO JFLD=1,KFDISTG
    IF(KFROM(JFLD) == IPROC(INR)) THEN
      IFLDCOUNT = IFLDCOUNT+1
      IFLDLOC(IFLDCOUNT)=JFLD
    ENDIF
  ENDDO
!$OMP PARALLEL PRIVATE(JFLD,JKGLO,IEND,IBL,ILOCFLD)
  IF (IFLDCOUNT > IGPBLKS) THEN
!$OMP DO SCHEDULE(STATIC)
    DO JFLD=1,IFLDCOUNT
      ILOCFLD=ISORT(IFLDLOC(JFLD))
      DO JKGLO=1,D%NGPTOT,KPROMA
        IEND = MIN(KPROMA,D%NGPTOT-JKGLO+1)
        IBL  = (JKGLO-1)/KPROMA+1
        PGP(1:IEND,ILOCFLD,IBL) = ZRCV(JKGLO:JKGLO+IEND-1,IOFFPROC(INR)+JFLD)
      ENDDO
    ENDDO
!$OMP END DO
  ELSE
!$OMP DO SCHEDULE(STATIC)
    DO JKGLO=1,D%NGPTOT,KPROMA
      DO JFLD=1,IFLDCOUNT
        ILOCFLD=ISORT(IFLDLOC(JFLD))
        IEND = MIN(KPROMA,D%NGPTOT-JKGLO+1)
        IBL  = (JKGLO-1)/KPROMA+1
        PGP(1:IEND,ILOCFLD,IBL) = ZRCV(JKGLO:JKGLO+IEND-1,IOFFPROC(INR)+JFLD)
      ENDDO
    ENDDO
!$OMP END DO
  ENDIF
!$OMP END PARALLEL
  CALL GSTATS(1663,1)
ENDDO

! Wait for send to complete
IF (IS > 0) THEN
  CALL GSTATS(811,0)
  CALL MPL_WAIT(KREQUEST=ISENDREQ(1:IS), CDSTRING='DIST_GRID_CTL: WAIT FOR SEND')
  CALL GSTATS(811,1)
ENDIF

CALL GSTATS_BARRIER2(791)

IF (.NOT. PRESENT (KSORT)) THEN
  DEALLOCATE (ISORT)
ENDIF

!     ------------------------------------------------------------------

END SUBROUTINE DIST_GRID_CTL
END MODULE DIST_GRID_CTL_MOD
