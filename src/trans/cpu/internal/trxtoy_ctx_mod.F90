! (C) Copyright 1995- ECMWF.
! (C) Copyright 1995- Meteo-France.
! 
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.
!

MODULE TRXTOY_CTX_MOD

USE PARKIND1, ONLY : JPIM

IMPLICIT NONE

TYPE TRXTOY_CTX
  INTEGER(KIND=JPIM) :: ISENDCOUNT = -9999
  INTEGER(KIND=JPIM) :: IRECVCOUNT = -9999
  INTEGER(KIND=JPIM) :: INSEND = -9999
  INTEGER(KIND=JPIM) :: INRECV = -9999
  INTEGER(KIND=JPIM), ALLOCATABLE :: ISENDTOT (:)
  INTEGER(KIND=JPIM), ALLOCATABLE :: IRECVTOT (:)
  INTEGER(KIND=JPIM), ALLOCATABLE :: ISEND    (:)
  INTEGER(KIND=JPIM), ALLOCATABLE :: IRECV    (:)
  INTEGER(KIND=JPIM), ALLOCATABLE :: IINDEX(:)
  INTEGER(KIND=JPIM), ALLOCATABLE :: INDOFF(:)
  INTEGER(KIND=JPIM), ALLOCATABLE :: IGPTRSEND(:,:,:)
  INTEGER(KIND=JPIM), ALLOCATABLE :: ISETAL(:), ISETBL(:), ISETWL(:), ISETVL(:)
  CONTAINS
    PROCEDURE :: ALLOCATE_CTX
END TYPE TRXTOY_CTX

CONTAINS 

SUBROUTINE ALLOCATE_CTX(SELF, NPROC,NLENGTF, NGPBLKS,NPRTRNS)
  CLASS(TRXTOY_CTX), INTENT(INOUT) :: SELF
  INTEGER(KIND=JPIM), INTENT(IN) :: NPROC,NLENGTF,NGPBLKS,NPRTRNS
    
  ALLOCATE (SELF%ISENDTOT (NPROC))
  ALLOCATE (SELF%IRECVTOT (NPROC))
  ALLOCATE (SELF%ISEND    (NPROC))
  ALLOCATE (SELF%IRECV    (NPROC))
  ALLOCATE (SELF%IINDEX(NLENGTF))
  ALLOCATE (SELF%INDOFF(NPROC))
  ALLOCATE (SELF%IGPTRSEND(2,NGPBLKS,NPRTRNS))
  ALLOCATE (SELF%ISETAL(NPROC))
  ALLOCATE (SELF%ISETBL(NPROC))
  ALLOCATE (SELF%ISETWL(NPROC))
  ALLOCATE (SELF%ISETVL(NPROC))
END SUBROUTINE ALLOCATE_CTX

SUBROUTINE ALLOCATE_HEAP_BUFFER(Z_HEAP, S1, S2)
  USE PARKIND1  ,ONLY : JPIM, JPRB

  IMPLICIT NONE

  REAL(KIND=JPRB), INTENT(INOUT), ALLOCATABLE :: Z_HEAP(:,:)
  INTEGER(KIND=JPIM), INTENT(IN) :: S1, S2  

  IF (ALLOCATED(Z_HEAP) .AND. (S1 /= SIZE(Z_HEAP,1) .OR. S2 /= SIZE(Z_HEAP,2) )) THEN
    DEALLOCATE(Z_HEAP)
  ENDIF

  IF (.NOT. ALLOCATED(Z_HEAP)) THEN
    ALLOCATE(Z_HEAP(-1:S1,S2))
  ENDIF

END SUBROUTINE ALLOCATE_HEAP_BUFFER


SUBROUTINE INIT_TOG_VARIABLES(KF_GP, KF_SCALARS_G, IUVLEVS,IUVPARS,IGP2PARS,LLUV,LLGP2,LLGP3A,LLGP3B, &
                            & IGP3APARS,IGP3ALEVS,IGP3BPARS,IGP3BLEVS, &
                            & PGP, PGPUV, PGP3A, PGP3B, PGP2)
  USE PARKIND1  ,ONLY : JPIM, JPRB
  USE TPM_TRANS       ,ONLY : LDIVGP, LGPNORM, LSCDERS, LUVDER, LVORGP, NGPBLKS
  IMPLICIT NONE
  
  INTEGER(KIND=JPIM), intent(in) :: KF_GP
  INTEGER(KIND=JPIM), intent(in):: KF_SCALARS_G  
  REAL(KIND=JPRB),OPTIONAL,INTENT(IN)     :: PGP(:,:,:)
  REAL(KIND=JPRB),OPTIONAL,INTENT(IN)     :: PGPUV(:,:,:,:)
  REAL(KIND=JPRB),OPTIONAL,INTENT(IN)     :: PGP3A(:,:,:,:)
  REAL(KIND=JPRB),OPTIONAL,INTENT(IN)     :: PGP3B(:,:,:,:)
  REAL(KIND=JPRB),OPTIONAL,INTENT(IN)     :: PGP2(:,:,:)
  INTEGER(KIND=JPIM), INTENT(OUT) :: IUVLEVS(KF_GP),IUVPARS(KF_GP),IGP2PARS(KF_GP)
  LOGICAL, INTENT(OUT)   :: LLUV(KF_GP),LLGP2(KF_GP),LLGP3A(KF_GP),LLGP3B(KF_GP)
  INTEGER(KIND=JPIM), INTENT(OUT) :: IGP3APARS(KF_GP),IGP3ALEVS(KF_GP),IGP3BPARS(KF_GP),IGP3BLEVS(KF_GP)
  
  ! Local variables
  LOGICAL   :: LLPGPUV,LLPGP3A,LLPGP3B,LLPGP2     
  INTEGER(KIND=JPIM) :: IUVPAR,IUVLEV,IGP2PAR,IGP3ALEV,IGP3APAR,IGP3BLEV,IGP3BPAR,IPAROFF
  INTEGER(KIND=JPIM) :: IOFF,IOFF1,IOFFNS,IOFFEW,J1,J2, JNR
  
  INTEGER(KIND=JPIM) ::  J
  
  LLPGPUV = .FALSE.
  LLPGP3A = .FALSE.
  LLPGP3B = .FALSE.
  LLPGP2  = .FALSE.
  
  IF(PRESENT(PGPUV))   LLPGPUV=.TRUE.
  IF(PRESENT(PGP3A))   LLPGP3A=.TRUE.
  IF(PRESENT(PGP3B))   LLPGP3B=.TRUE.
  IF(PRESENT(PGP2))    LLPGP2=.TRUE.
  
  IUVPAR=0
  IUVLEV=0
  IOFF1=0
  IOFFNS=KF_SCALARS_G
  IOFFEW=2*KF_SCALARS_G

  LLUV(:) = .FALSE.
  IUVPARS(:) = -99
  IUVLEVS(:) = -99

  IF (LLPGPUV) THEN
  IOFF=0
  IUVLEV=UBOUND(PGPUV,2)
  IF(LVORGP) THEN
    IUVPAR=IUVPAR+1
    DO J=1,IUVLEV
      IUVLEVS(IOFF+J)=J
      IUVPARS(IOFF+J)=IUVPAR
      LLUV(IOFF+J)=.TRUE.
    ENDDO
    IOFF=IOFF+IUVLEV
  ENDIF
  IF(LDIVGP) THEN
    IUVPAR=IUVPAR+1
    DO J=1,IUVLEV
      IUVLEVS(IOFF+J)=J
      IUVPARS(IOFF+J)=IUVPAR
      LLUV(IOFF+J)=.TRUE.
    ENDDO
    IOFF=IOFF+IUVLEV
  ENDIF
  DO J=1,IUVLEV
    IUVLEVS(IOFF+J)=J
    IUVPARS(IOFF+J)=IUVPAR+1
    IUVLEVS(IOFF+J+IUVLEV)=J
    IUVPARS(IOFF+J+IUVLEV)=IUVPAR+2
  ENDDO
  IUVPAR=IUVPAR+2
  LLUV(IOFF+1:IOFF+2*IUVLEV)=.TRUE.
  IOFF=IOFF+2*IUVLEV
  IOFF1=IOFF
  IOFFNS=IOFFNS+IOFF
  IOFFEW=IOFFEW+IOFF

  IOFF=IUVPAR*IUVLEV+KF_SCALARS_G
  IF(LUVDER) THEN
    IF(LSCDERS) IOFF=IOFF+KF_SCALARS_G
    DO J=1,IUVLEV
      IUVLEVS(IOFF+J)=J
      IUVPARS(IOFF+J)=IUVPAR+1
      LLUV(IOFF+J)=.TRUE.
      IUVLEVS(IOFF+J+IUVLEV)=J
      IUVPARS(IOFF+J+IUVLEV)=IUVPAR+2
      LLUV(IOFF+J+IUVLEV)=.TRUE.
    ENDDO
    IUVPAR=IUVPAR+2
    IOFF=IOFF+2*IUVLEV
    IOFFEW=IOFFEW+2*IUVLEV
  ENDIF
ENDIF

LLGP2(:)=.FALSE.
IF(LLPGP2) THEN
  IOFF=IOFF1
  IGP2PAR=UBOUND(PGP2,2)
  IF(LSCDERS) IGP2PAR=IGP2PAR/3
  DO J=1,IGP2PAR
    LLGP2(J+IOFF) = .TRUE.
    IGP2PARS(J+IOFF)=J
  ENDDO
  IOFF1=IOFF1+IGP2PAR
  IF(LSCDERS) THEN
    IOFF=IOFFNS
    DO J=1,IGP2PAR
      LLGP2(J+IOFF) = .TRUE.
      IGP2PARS(J+IOFF)=J+IGP2PAR
    ENDDO
    IOFFNS=IOFF+IGP2PAR
    IOFF=IOFFEW
    DO J=1,IGP2PAR
      LLGP2(J+IOFF) = .TRUE.
      IGP2PARS(J+IOFF)=J+2*IGP2PAR
    ENDDO
    IOFFEW=IOFF+IGP2PAR
  ENDIF
ENDIF

LLGP3A(:) = .FALSE.
IF(LLPGP3A) THEN
  IGP3ALEV=UBOUND(PGP3A,2)
  IGP3APAR=UBOUND(PGP3A,3)
  IF(LSCDERS) IGP3APAR=IGP3APAR/3
  IOFF=IOFF1
  DO J1=1,IGP3APAR
    DO J2=1,IGP3ALEV
      LLGP3A(J2+(J1-1)*IGP3ALEV+IOFF) = .TRUE.
      IGP3APARS(J2+(J1-1)*IGP3ALEV+IOFF)=J1
      IGP3ALEVS(J2+(J1-1)*IGP3ALEV+IOFF)=J2
    ENDDO
  ENDDO
  IPAROFF=IGP3APAR
  IOFF1=IOFF1+IGP3APAR*IGP3ALEV
  IF(LSCDERS) THEN
    IOFF=IOFFNS
    DO J1=1,IGP3APAR
      DO J2=1,IGP3ALEV
        LLGP3A(J2+(J1-1)*IGP3ALEV+IOFF) = .TRUE.
        IGP3APARS(J2+(J1-1)*IGP3ALEV+IOFF)=J1+IPAROFF
        IGP3ALEVS(J2+(J1-1)*IGP3ALEV+IOFF)=J2
      ENDDO
    ENDDO
    IPAROFF=IPAROFF+IGP3APAR
    IOFFNS=IOFFNS+IGP3APAR*IGP3ALEV
    IOFF=IOFFEW
    DO J1=1,IGP3APAR
      DO J2=1,IGP3ALEV
        LLGP3A(J2+(J1-1)*IGP3ALEV+IOFF) = .TRUE.
        IGP3APARS(J2+(J1-1)*IGP3ALEV+IOFF)=J1+IPAROFF
        IGP3ALEVS(J2+(J1-1)*IGP3ALEV+IOFF)=J2
      ENDDO
    ENDDO
    IOFFEW=IOFFEW+IGP3APAR*IGP3ALEV
  ENDIF
ENDIF

LLGP3B(:) = .FALSE.
IF(LLPGP3B) THEN
  IGP3BLEV=UBOUND(PGP3B,2)
  IGP3BPAR=UBOUND(PGP3B,3)
  IF(LSCDERS) IGP3BPAR=IGP3BPAR/3
  IOFF=IOFF1
  DO J1=1,IGP3BPAR
    DO J2=1,IGP3BLEV
      LLGP3B(J2+(J1-1)*IGP3BLEV+IOFF) = .TRUE.
      IGP3BPARS(J2+(J1-1)*IGP3BLEV+IOFF)=J1
      IGP3BLEVS(J2+(J1-1)*IGP3BLEV+IOFF)=J2
    ENDDO
  ENDDO
  IPAROFF=IGP3BPAR
  IOFF1=IOFF1+IGP3BPAR*IGP3BLEV
  IF(LSCDERS) THEN
    IOFF=IOFFNS
    DO J1=1,IGP3BPAR
      DO J2=1,IGP3BLEV
        LLGP3B(J2+(J1-1)*IGP3BLEV+IOFF) = .TRUE.
        IGP3BPARS(J2+(J1-1)*IGP3BLEV+IOFF)=J1+IPAROFF
        IGP3BLEVS(J2+(J1-1)*IGP3BLEV+IOFF)=J2
      ENDDO
    ENDDO
    IPAROFF=IPAROFF+IGP3BPAR
    IOFFNS=IOFFNS+IGP3BPAR*IGP3BLEV
    IOFF=IOFFEW
    DO J1=1,IGP3BPAR
      DO J2=1,IGP3BLEV
        LLGP3B(J2+(J1-1)*IGP3BLEV+IOFF) = .TRUE.
        IGP3BPARS(J2+(J1-1)*IGP3BLEV+IOFF)=J1+IPAROFF
        IGP3BLEVS(J2+(J1-1)*IGP3BLEV+IOFF)=J2
      ENDDO
    ENDDO
    IOFFEW=IOFFEW+IGP3BPAR*IGP3BLEV
  ENDIF
ENDIF

END SUBROUTINE INIT_TOG_VARIABLES
END MODULE TRXTOY_CTX_MOD
