MODULE OVERLAP_TYPES_MOD
  USE LINKED_LIST_M, ONLY: LINKEDLIST
  USE PARKIND1,      ONLY: JPIM, JPRB

  IMPLICIT NONE
  PRIVATE

  TYPE, PUBLIC :: BATCH
      INTEGER(KIND=JPIM) :: NBLK
      INTEGER(KIND=JPIM) :: NSTUV_G
      INTEGER(KIND=JPIM) :: NENUV_G
      INTEGER(KIND=JPIM) :: NF_UV_G
      INTEGER(KIND=JPIM) :: NSTSC_G
      INTEGER(KIND=JPIM) :: NENSC_G
      INTEGER(KIND=JPIM) :: NF_SCALARS_G
      INTEGER(KIND=JPIM) :: NSTUV
      INTEGER(KIND=JPIM) :: NENUV
      INTEGER(KIND=JPIM) :: NF_UV
      INTEGER(KIND=JPIM) :: NSTSC
      INTEGER(KIND=JPIM) :: NENSC
      INTEGER(KIND=JPIM) :: NF_SCALARS
      INTEGER(KIND=JPIM) :: NF_FS
      INTEGER(KIND=JPIM) :: NF_GP
      INTEGER(KIND=JPIM), ALLOCATABLE :: NSHFUV_G(:)
      INTEGER(KIND=JPIM), ALLOCATABLE :: NSHFSC_G(:)
      INTEGER(KIND=JPIM), ALLOCATABLE :: NVSETUV(:)
      INTEGER(KIND=JPIM), ALLOCATABLE :: NVSETSC(:)
      INTEGER(KIND=JPIM), ALLOCATABLE :: NPTRGP(:)
      INTEGER(KIND=JPIM), ALLOCATABLE :: NPTRSPUV(:)
      INTEGER(KIND=JPIM), ALLOCATABLE :: NPTRSPSC(:)
      INTEGER(KIND=JPIM), ALLOCATABLE :: NVSET(:)
      INTEGER(KIND=JPIM) :: IOFFGTF
      INTEGER(KIND=JPIM) :: NSENDCOUNT
      INTEGER(KIND=JPIM) :: NRECVCOUNT
      INTEGER(KIND=JPIM) :: NNSEND
      INTEGER(KIND=JPIM) :: NNRECV
      INTEGER(KIND=JPIM), ALLOCATABLE :: NSENDTOT(:)
      INTEGER(KIND=JPIM), ALLOCATABLE :: NRECVTOT(:)
      INTEGER(KIND=JPIM), ALLOCATABLE :: NSEND(:)
      INTEGER(KIND=JPIM), ALLOCATABLE :: NRECV(:)
      INTEGER(KIND=JPIM), ALLOCATABLE :: NINDEX(:)
      INTEGER(KIND=JPIM), ALLOCATABLE :: NNDOFF(:)
      INTEGER(KIND=JPIM), ALLOCATABLE :: NGPTRSEND(:,:,:)
      REAL(KIND=JPRB), ALLOCATABLE :: PCOMBUFS(:,:)
      REAL(KIND=JPRB), ALLOCATABLE :: PCOMBUFR(:,:)
!      INTEGER(KIND=JPIM), ALLOCATABLE :: NREQ_RECV(:)
  CONTAINS
      PROCEDURE :: START_COMM
      PROCEDURE :: COMM_COMPLETE
      PROCEDURE :: FINISH_COMM
  END TYPE BATCH

  INTERFACE BATCH
      MODULE PROCEDURE :: BATCH_CONSTRUCTOR
  END INTERFACE BATCH

  TYPE, PUBLIC, EXTENDS(LINKEDLIST) :: BATCHLIST
  CONTAINS
      PROCEDURE :: APPEND => APPEND_BATCH
  END TYPE BATCHLIST

CONTAINS

    ! -----------------------------------------------------------------------------
    ! Batch methods
    ! -----------------------------------------------------------------------------

    FUNCTION BATCH_CONSTRUCTOR(KBLK, KF_GP, KF_SCALARS_G, KF_UV_G, KVSETUV, KVSETSC,NPTRFS,IOFFSEND,IOFFRECV,IOFFGTF,SENDCNTMAX,RECVCNTMAX) RESULT(THIS)
        USE SHUFFLE_MOD,     ONLY: SHUFFLE
        USE FIELD_SPLIT_MOD, ONLY: FIELD_SPLIT
        USE TPM_GEN,         ONLY: NPROMATR, NOUT
        USE TPM_DISTR,       ONLY: D, NPRTRNS, NPROC
        USE TPM_TRANS,       ONLY: NGPBLKS
        USE TRGTOL_MOD,      ONLY: TRGTOL_PROLOG
!        USE COMMON_MOD
        
        INTEGER(KIND=JPIM), INTENT(IN) :: KBLK
        INTEGER(KIND=JPIM), INTENT(IN) :: KF_GP
        INTEGER(KIND=JPIM), INTENT(IN) :: KF_SCALARS_G
        INTEGER(KIND=JPIM), INTENT(IN) :: KF_UV_G
        ! Not actually optional!
        INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)  :: KVSETUV(:)
        INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN)  :: KVSETSC(:)
        INTEGER(KIND=JPIM), ALLOCATABLE :: NPTRFS(:)
        INTEGER(KIND=JPIM),  INTENT(INOUT)  :: IOFFSEND,IOFFRECV,IOFFGTF
        INTEGER(KIND=JPIM),  INTENT(IN)  :: SENDCNTMAX,RECVCNTMAX

        INTEGER :: JFLD, IST
        
        TYPE(BATCH) :: THIS

        THIS%NBLK = KBLK

        ALLOCATE(THIS%NSHFUV_G(KF_GP))
        ALLOCATE(THIS%NSHFSC_G(KF_GP))
        ALLOCATE(THIS%NVSETUV(KF_GP))
        ALLOCATE(THIS%NVSETSC(KF_GP))

        CALL SHUFFLE(KF_UV_G, KF_SCALARS_G, THIS%NSHFUV_G, THIS%NVSETUV, THIS%NSHFSC_G, &
          &          THIS%NVSETSC, KVSETUV, KVSETSC)

        CALL FIELD_SPLIT(KBLK, KF_GP, KF_UV_G, THIS%NVSETUV, THIS%NVSETSC, THIS%NSTUV_G, &
          &              THIS%NENUV_G, THIS%NF_UV_G, THIS%NSTSC_G, THIS%NENSC_G, &
          &              THIS%NF_SCALARS_G, THIS%NSTUV, THIS%NENUV, THIS%NF_UV, THIS%NSTSC, &
          &              THIS%NENSC, THIS%NF_SCALARS)

        THIS%NF_FS = 2*THIS%NF_UV + THIS%NF_SCALARS
        THIS%NF_GP = 2*THIS%NF_UV_G + THIS%NF_SCALARS_G

        ALLOCATE(THIS%NPTRGP(THIS%NF_GP))
        ALLOCATE(THIS%NPTRSPUV(NPROMATR))
        ALLOCATE(THIS%NPTRSPSC(NPROMATR))

        DO JFLD = 1, THIS%NF_UV_G
          THIS%NPTRGP(JFLD) = THIS%NSHFUV_G(THIS%NSTUV_G+JFLD-1)
          THIS%NPTRGP(JFLD+THIS%NF_UV_G) = KF_UV_G + THIS%NSHFUV_G(THIS%NSTUV_G+JFLD-1)
        ENDDO
        DO JFLD = 1, THIS%NF_SCALARS_G
          THIS%NPTRGP(JFLD+2*THIS%NF_UV_G) = 2*KF_UV_G + THIS%NSHFSC_G(THIS%NSTSC_G+JFLD-1)
        ENDDO
        DO JFLD = 1, THIS%NF_UV
          THIS%NPTRSPUV(JFLD) = THIS%NSTUV + JFLD - 1
        ENDDO
        DO JFLD = 1, THIS%NF_SCALARS
          THIS%NPTRSPSC(JFLD) = THIS%NSTSC + JFLD - 1
        ENDDO

        ! Compute this batch's offset into PGTF
!        THIS%IOFFGTF = (THIS%NBLK - 1) * NPROMATR + 1
!        IF(KBLK .EQ. 1) THEN
!           NPTRFS(1) = 1
!        ENDIF
!        NPTRFS(KBLK+1) = NPTRFS(KBLK) + THIS%NF_GP
!        THIS%IOFFGTF = NPTRFS(KBLK)
        THIS%IOFFGTF = IOFFGTF
        IOFFGTF = IOFFGTF + THIS%NF_FS
        
        ALLOCATE(THIS%NVSET(THIS%NF_GP))
        IST = 1
        IF (THIS%NF_UV_G > 0) THEN
          THIS%NVSET(IST:IST+THIS%NF_UV_G-1) = THIS%NVSETUV(THIS%NSTUV_G:THIS%NENUV_G)
          IST = IST + THIS%NF_UV_G
          THIS%NVSET(IST:IST+THIS%NF_UV_G-1) = THIS%NVSETUV(THIS%NSTUV_G:THIS%NENUV_G)
          IST = IST + THIS%NF_UV_G
        ENDIF
        IF (THIS%NF_SCALARS_G > 0) THEN
          THIS%NVSET(IST:IST+THIS%NF_SCALARS_G-1) = THIS%NVSETSC(THIS%NSTSC_G:THIS%NENSC_G)
          IST = IST + THIS%NF_SCALARS_G
        ENDIF

        ALLOCATE(THIS%NSENDTOT(NPROC))
        ALLOCATE(THIS%NRECVTOT(NPROC))
        ALLOCATE(THIS%NSEND(NPROC))
        ALLOCATE(THIS%NRECV(NPROC))
        ALLOCATE(THIS%NINDEX(D%NLENGTF))
        ALLOCATE(THIS%NNDOFF(NPROC))
        ALLOCATE(THIS%NGPTRSEND(2,NGPBLKS,NPRTRNS))
        CALL TRGTOL_PROLOG(THIS%NF_FS, THIS%NF_GP, THIS%NVSET, THIS%NSENDCOUNT, THIS%NRECVCOUNT, &
          &                THIS%NNSEND, THIS%NNRECV, THIS%NSENDTOT, THIS%NRECVTOT, THIS%NSEND, &
          &                THIS%NRECV, THIS%NINDEX, THIS%NNDOFF, THIS%NGPTRSEND)

!        ALLOCATE(THIS%PCOMBUFS(-1:THIS%NSENDCOUNT,THIS%NNSEND))
        
        ! Now, force the OS to allocate this shared array right now, not when it starts to be used which is
        ! an OPEN-MP loop, that would cause a threads synchronization lock :
 
!       ALLOCATE(THIS%PCOMBUFR(-1:THIS%NRECVCOUNT,THIS%NNRECV))

        ALLOCATE(THIS%NREQ_RECV(NPROC))

        THIS%MYOFFSEND = IOFFSEND
        IOFFSEND = IOFFSEND + SENDCNTMAX
        THIS%MYOFFRECV = IOFFRECV
        IOFFRECV = IOFFRECV + RECVCNTMAX

      END FUNCTION BATCH_CONSTRUCTOR

    SUBROUTINE START_COMM(THIS, PGP, IREQ_RECV,PGTF,PCOMBUFS,PCOMBUFR)
        USE TRGTOL_MOD, ONLY: TRGTOL_COMM_SEND
        USE TPM_GEN, ONLY: NOUT
        
        CLASS(BATCH),              INTENT(INOUT) :: THIS
        REAL(KIND=JPRB), OPTIONAL, INTENT(IN)    :: PGP(:,:,:)
        REAL(KIND=JPRB),           INTENT(OUT)   :: PGTF(:,:)
        REAL(KIND=JPRB), ALLOCATABLE :: PCOMBUFR(:,:),PCOMBUFS(:,:)
        INTEGER(KIND=JPIM), INTENT(INOUT) :: IREQ_RECV(:)
        
        WRITE(NOUT,*) "DEBUG", THIS%IOFFGTF, THIS%NF_FS
        FLUSH(NOUT)

        CALL TRGTOL_COMM_SEND(PGTF(THIS%IOFFGTF:THIS%IOFFGTF+THIS%NF_FS-1,:), &
          &                   PCOMBUFS(THIS%IOFFSEND:THIS%IOFFSEND+THIS%SENDCNTMAX,:), &
          &                   PCOMBUFR(THIS%IOFFRECV:THIS%IOFFRECV+THIS%RECVCNTMAX,:), &
          &              THIS%NF_FS, THIS%NF_GP, THIS%NF_SCALARS_G, THIS%NVSET, THIS%NSENDCOUNT, &
          &                   THIS%NRECVCOUNT, THIS%NNSEND, THIS%NNRECV, THIS%NSENDTOT, &
          &                   THIS%NRECVTOT, THIS%NSEND, THIS%NRECV, THIS%NINDEX, THIS%NNDOFF, &
          &                   THIS%NGPTRSEND, THIS%MYOFFSEND, THIS%MYOFFRECV,THIS%NREQ_RECV, &
          &                   THIS%NPTRGP, PGP)
    END SUBROUTINE START_COMM

    FUNCTION COMM_COMPLETE(THIS)
      USE MPI,     ONLY: MPI_STATUS_SIZE, MPI_TESTALL

      CLASS(BATCH), INTENT(INOUT) :: THIS

      LOGICAL :: COMM_COMPLETE
      INTEGER(KIND=JPIM), ALLOCATABLE :: ISTATS(:,:)
      INTEGER(KIND=JPIM) :: IERROR

      ALLOCATE(ISTATS(MPI_STATUS_SIZE,THIS%NNRECV))

      COMM_COMPLETE = .FALSE.
      DO WHILE(.NOT. COMM_COMPLETE)
        CALL MPI_TESTALL(THIS%NNRECV, IREQ_RECV(1:THIS%NNRECV), COMM_COMPLETE, ISTATS, IERROR)
      ENDDO
    END FUNCTION COMM_COMPLETE

    SUBROUTINE FINISH_COMM(THIS, PGTF, IREQ_RECV,PCOMBUFR,PSPVOR, PSPDIV, PSPSCALAR)
      USE TRGTOL_MOD,    ONLY: TRGTOL_COMM_RECV
      USE FTDIR_CTL_MOD, ONLY: FTDIR_CTL_COMP
      USE LTDIR_CTL_MOD, ONLY: LTDIR_CTL

      CLASS(BATCH),              INTENT(INOUT) :: THIS
      REAL(KIND=JPRB),           INTENT(INOUT) :: PGTF(:,:)
      REAL(KIND=JPRB), OPTIONAL, INTENT(INOUT) :: PSPVOR(:,:)
      REAL(KIND=JPRB), OPTIONAL, INTENT(INOUT) :: PSPDIV(:,:)
      REAL(KIND=JPRB), OPTIONAL, INTENT(INOUT) :: PSPSCALAR(:,:)
      REAL(KIND=JPRB), ALLOCATABLE :: PCOMBUFR(:,:)
      INTEGER(KIND=JPIM), INTENT(INOUT) :: IREQ_RECV(:)
      
      CALL TRGTOL_COMM_RECV(PGTF(THIS%IOFFGTF:THIS%IOFFGTF+THIS%NF_FS-1,:), 
          &                 PCOMBUFR(THIS%IOFFRECV:THIS%IOFFRECV+THIS%RECVCNTMAX,:), &
        &                   THIS%NF_FS, THIS%NRECVCOUNT, THIS%NNRECV, THIS%NRECVTOT, THIS%NRECV, &
        &                   THIS%NINDEX, THIS%NNDOFF, THIS%MYOFFRECV, IREQ_RECV)
      CALL FTDIR_CTL_COMP(PGTF(THIS%IOFFGTF:THIS%IOFFGTF+THIS%NF_FS-1,:), THIS%NF_FS)
      CALL LTDIR_CTL(THIS%NF_FS, THIS%NF_UV, THIS%NF_SCALARS, PSPVOR=PSPVOR, PSPDIV=PSPDIV, &
        &            PSPSCALAR=PSPSCALAR, KFLDPTRUV=THIS%NPTRSPUV, KFLDPTRSC=THIS%NPTRSPSC)
    END SUBROUTINE FINISH_COMM

    ! -----------------------------------------------------------------------------
    ! BATCHLIST methods
    ! -----------------------------------------------------------------------------

    ! Add a value to the list at the tail
    SUBROUTINE APPEND_BATCH(THIS, VALUE)
      USE LINKED_LIST_M, ONLY: LINKEDLISTNODE

      CLASS(BATCHLIST), INTENT(INOUT) :: THIS
      CLASS(*), INTENT(IN), TARGET    :: VALUE

      TYPE(LINKEDLISTNODE), POINTER :: NODE_PTR, NEXT_PTR, CURRENT_PTR

      ! Create a new node and set the value
      ALLOCATE(NODE_PTR)
      ALLOCATE(NODE_PTR%VALUE, SOURCE=VALUE)
      NODE_PTR%NEXT => NULL()
      THIS%SIZE = THIS%SIZE + 1

      IF (.NOT. ASSOCIATED(THIS%HEAD))THEN
         THIS%HEAD => NODE_PTR
         THIS%TAIL => NODE_PTR
      ELSE
         THIS%TAIL%NEXT => NODE_PTR
         NODE_PTR%PREV  => THIS%TAIL
         THIS%TAIL      => NODE_PTR
      END IF

  END SUBROUTINE APPEND_BATCH

END MODULE OVERLAP_TYPES_MOD
