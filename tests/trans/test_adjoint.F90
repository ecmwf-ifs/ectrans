! (C) Copyright 2005- ECMWF.
! 
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.
!

PROGRAM TEST_ADJOINT

USE PARKIND1,        ONLY: JPIM, JPRB
USE MPL_MODULE,      ONLY: MPL_INIT, MPL_END, MPL_BARRIER, MPL_MYRANK
USE ABORT_TRANS_MOD, ONLY: ABORT_TRANS

IMPLICIT NONE

INTEGER(KIND=JPIM) :: NSMAX, NDGL, NPROC, NPRGPNS, NPRGPEW, NPRTRW, NPRTRV
INTEGER(KIND=JPIM) :: NOUT, MYPROC, NSPECG, NSPEC2G
INTEGER(KIND=JPIM) :: NFLEV, NFLEVG
INTEGER(KIND=JPIM) :: NSPEC2, NGPTOT, NPROMA, NGPBLKS, MYSETV, NUMP
INTEGER(KIND=JPIM) :: IVSET(1000)
INTEGER(KIND=JPIM), ALLOCATABLE :: NLOEN(:), ITO(:), MYMS(:), NASM0(:)
INTEGER(KIND=JPIM) :: JLEV, JREP

CHARACTER*6 CLNAME

REAL(KIND=JPRB) , ALLOCATABLE :: ZSPECX(:,:), ZSPECY(:,:), ZSPECP(:,:)
REAL(KIND=JPRB) , ALLOCATABLE :: ZVORX(:,:), ZVORY(:,:), ZVORP(:,:)
REAL(KIND=JPRB) , ALLOCATABLE :: ZDIVX(:,:), ZDIVY(:,:), ZDIVP(:,:)
REAL(KIND=JPRB) , ALLOCATABLE :: ZGX(:,:,:)
REAL(KIND=JPRB) , ALLOCATABLE :: ZSPECYG(:,:), ZSPECXG(:,:)
REAL(KIND=JPRB) , ALLOCATABLE :: ZRANDSP(:)
REAL(KIND=JPRB) :: ZSC1, ZSC2, ZRELATIVE_ERROR
REAL(KIND=JPRB),EXTERNAL :: TIMEF
LOGICAL :: LMPOFF
REAL(KIND=JPRB) :: ZAVEAVE(0:200)

#include "setup_trans0.h"
#include "setup_trans.h"
#include "trans_inq.h"
#include "dir_trans.h"
#include "inv_trans.h"
#include "dir_transad.h"
#include "inv_transad.h"
#include "dist_grid.h"
#include "gath_spec.h"
#include "dist_spec.h"

! ======== PARAMETERS WHICH MAY BE MODIFIED, ORIGINALLY COMING FROM NAMELIST ===========
NDGL = 32 ! Number of latitudes from pole to equator
NFLEVG = 9 ! Number of levels
NPROMA = 8 ! Gridpoint block size
NPRGPNS = 1
NPRGPEW = 1   ! NPROC must match NPRGPNS * NPRGPEW
NPRTRW = 1
NPRTRV = 1
! ======================================================================================

! Validate NPROC/NPRGPNS/NPRTGPEW correspondence
NPROC = NPRGPNS*NPRGPEW
IF (NPROC /= NPRTRW*NPRTRV) THEN
  PRINT *,'NPRGPNS,NPRGPEW,NPRTRW,NPRTRV ',NPRGPNS,NPRGPEW,NPRTRW,NPRTRV
  CALL ABORT_TRANS('NPRGPNS*NPRGPEW /= NPRTRW*NPRTRV')
ENDIF

! Determine spectral space parameters
NSMAX = (2 * NDGL - 1) / 3 ! Full Gaussian grid
NSPECG = (NSMAX+1)*(NSMAX+2)/2
NSPEC2G = NSPECG*2

! Set output configuration
IF (NPROC > 1 ) THEN
  CALL MPL_INIT
  MYPROC = MPL_MYRANK()
  NOUT = 20
  WRITE(CLNAME,'(A,I2.2)') 'OUT.',MYPROC
  OPEN(NOUT,FILE=CLNAME)
  LMPOFF = .FALSE.
ELSE
  LMPOFF = .TRUE.
  NOUT = 6
  MYPROC = 1
ENDIF

WRITE(NOUT,*) ' NSMAX= ',NSMAX
WRITE(NOUT,*) ' NDGL=',NDGL
WRITE(NOUT,*) ' LMPOFF= ',LMPOFF

MYSETV = MOD(MYPROC-1,NPRTRV)+1
ALLOCATE(ZSPECYG(NFLEVG,NSPEC2G))
ALLOCATE(ZSPECXG(NFLEVG,NSPEC2G))
ALLOCATE(ZRANDSP(NSPEC2G))
ALLOCATE(NLOEN(NDGL))
ALLOCATE(ITO(NFLEVG))
NLOEN(:) = 2*NDGL

! Initialise ecTrans
CALL SETUP_TRANS0(KOUT=NOUT, KERR=0, KPRINTLEV=0, KMAX_RESOL=1, KPRGPNS=NPRGPNS, KPRGPEW=NPRGPEW, &
  &               KPRTRW=NPRTRW, LDMPOFF=LMPOFF)
CALL SETUP_TRANS(KSMAX=NSMAX, KDGL=NDGL, KLOEN=NLOEN, LDSPLIT=.TRUE.)

CALL TRANS_INQ(KSPEC2=NSPEC2, KGPTOT=NGPTOT, KNUMP=NUMP)

ALLOCATE(MYMS(NUMP))
ALLOCATE(NASM0(0:NSMAX))
CALL TRANS_INQ(KMYMS=MYMS,KASM0=NASM0)
NGPBLKS = (NGPTOT-1)/NPROMA+1

WRITE(NOUT,*) ' NSPEC2=',NSPEC2
WRITE(NOUT,*) ' NGPTOT=',NGPTOT

NFLEV = 0
DO JLEV=1,NFLEVG
  IVSET(JLEV) = MOD(JLEV,NPRTRV)+1
  IF (IVSET(JLEV) == MYSETV) THEN
    NFLEV = NFLEV+1
  ENDIF
ENDDO
WRITE(NOUT,*)' NFLEV=',NFLEV
WRITE(NOUT,*) 'SETUP FINISHED'
FLUSH(NOUT)

ALLOCATE(ZSPECX(NFLEV,NSPEC2))
ALLOCATE(ZSPECY(NFLEV,NSPEC2))
ALLOCATE(ZSPECP(NFLEV,NSPEC2))
ALLOCATE(ZVORX(NFLEV,NSPEC2))
ALLOCATE(ZVORY(NFLEV,NSPEC2))
ALLOCATE(ZVORP(NFLEV,NSPEC2))
ALLOCATE(ZDIVX(NFLEV,NSPEC2))
ALLOCATE(ZDIVY(NFLEV,NSPEC2))
ALLOCATE(ZDIVP(NFLEV,NSPEC2))
ALLOCATE(ZGX(NPROMA,3*NFLEVG,NGPBLKS))

! Prepare perturbations (random numbers between -1 and +1)
IF (MYPROC == 1) THEN
  DO JLEV=1,NFLEVG
    CALL RANDOM_NUMBER(ZRANDSP)
    ZSPECYG(JLEV,:) = (1.0_JPRB-2.0_JPRB*ZRANDSP(:))
    CALL RANDOM_NUMBER(ZRANDSP)
    ZSPECXG(JLEV,:) = (1.0_JPRB-2.0_JPRB*ZRANDSP(:))
  ENDDO
ENDIF
ITO(:) = 1
ZVORX = 0.0_JPRB
ZVORY = 0.0_JPRB
ZVORP = 0.0_JPRB
ZDIVX = 0.0_JPRB
ZDIVY = 0.0_JPRB
ZDIVP = 0.0_JPRB

CALL DIST_SPEC(PSPECG=ZSPECXG, KFDISTG=NFLEVG, KFROM=ITO, PSPEC=ZSPECX, KVSET=IVSET(1:NFLEVG))
CALL DIST_SPEC(PSPECG=ZSPECYG, KFDISTG=NFLEVG, KFROM=ITO, PSPEC=ZSPECY, KVSET=IVSET(1:NFLEVG))

! Calculate DIR_TRANS(INV_TRANS(X))
CALL INV_TRANS(PSPSCALAR=ZSPECX, PSPVOR=ZVORX, PSPDIV=ZDIVX, PGP=ZGX, &
  & KPROMA=NPROMA, KVSETSC=IVSET(1:NFLEVG), KVSETUV=IVSET(1:NFLEVG))
CALL DIR_TRANS(PSPSCALAR=ZSPECP, PSPVOR=ZVORP, PSPDIV=ZDIVP, PGP=ZGX, &
  &KPROMA=NPROMA, KVSETSC=IVSET(1:NFLEVG), KVSETUV=IVSET(1:NFLEVG))

! Calculate <DIR_TRANS(INV_TRANS(X)), Y>
CALL SCALPRODSP(ZSPECP, ZSPECY, ZSC1, IVSET)
WRITE(NOUT,*)'<Fx,y> ',ZSC1

ZSPECP = 0.0_JPRB
! Calculate INV_TRANSAD(DIR_TRANSAD(Y))
CALL DIR_TRANSAD(PSPSCALAR=ZSPECY, PSPVOR=ZVORY, PSPDIV=ZDIVY, PGP=ZGX, &
  &KPROMA=NPROMA, KVSETSC=IVSET(1:NFLEVG), KVSETUV=IVSET(1:NFLEVG))
CALL INV_TRANSAD(PSPSCALAR=ZSPECP, PSPVOR=ZVORP, PSPDIV=ZDIVP, PGP=ZGX, &
  & KPROMA=NPROMA, KVSETSC=IVSET(1:NFLEVG), KVSETUV=IVSET(1:NFLEVG))

! Calculate <X, INV_TRANSAD(DIR_TRANSAD(Y))>
CALL SCALPRODSP(ZSPECX, ZSPECP, ZSC2, IVSET)
WRITE(NOUT,*)'<x,F*y> ',ZSC2

! Calculate relative error between <DIR_TRANS(INV_TRANS(X)), Y> and <X, INV_TRANSAD(DIR_TRANSAD(Y))>
ZRELATIVE_ERROR = ABS(ZSC1 - ZSC2)/ABS(ZSC1)

! Abort if relative error is > 100 * machine epsilon
IF (ZRELATIVE_ERROR > 100.0*EPSILON(1.0_JPRB)) THEN
  WRITE(NOUT, '(A)') '*******************************'
  WRITE(NOUT, '(A)') 'Adjoint test failed'
  WRITE(NOUT, '(A,1E9.2)') '<Fx,y>  = ', ZSC1
  WRITE(NOUT, '(A,1E9.2)') '<x,F*y> = ', ZSC2
  WRITE(NOUT, '(A,1E9.2)') 'Relative error = ', ZRELATIVE_ERROR
  WRITE(NOUT, '(A)') '*******************************'
  ERROR STOP
ENDIF

IF (NPROC > 1 ) THEN
 CALL MPL_BARRIER()
 CALL MPL_END
ENDIF

CONTAINS

SUBROUTINE SCALPRODSP(PSP1,PSP2,PSC,KVSET)

! Scalar product in spectral space
REAL(KIND=JPRB) :: PSP1(:,:),PSP2(:,:)
REAL(KIND=JPRB) :: PSC
INTEGER(KIND=JPIM) :: KVSET(:)

INTEGER(KIND=JPIM) :: JMLOC, IM, JIR, JN, INM, JLEV
REAL(KIND=JPRB) :: ZMFACT, ZSP(NFLEV,NSPEC2), ZSPG(NFLEVG,NSPEC2G)

PSC = 0.0_JPRB
ZSP(:,:) = 0.0_JPRB

!$OMP PARALLEL DO SCHEDULE(STATIC,1) PRIVATE(JLEV,JMLOC,IM,ZMFACT,JIR,JN,INM)
DO JLEV=1,NFLEV
  DO JMLOC=1,NUMP
    IM = MYMS(JMLOC)
    ZMFACT=1.0_JPRB+REAL(MIN(1,IM),JPRB)
    DO JIR=0,MIN(1,IM)
      DO JN=IM,NSMAX
        INM = NASM0(IM)+(JN-IM)*2+JIR
        ZSP(JLEV,INM) = PSP1(JLEV,INM)*PSP2(JLEV,INM)*ZMFACT/2.0_JPRB
      ENDDO
    ENDDO
  ENDDO
ENDDO
!$OMP END PARALLEL DO

CALL GATH_SPEC(PSPECG=ZSPG,KFGATHG=NFLEVG,KTO=ITO,PSPEC=ZSP,&
 & KVSET=KVSET(1:NFLEVG))

IF(MYPROC == 1) THEN
  PSC = SUM(ZSPG)
ELSE
  PSC = 0.0_JPRB
ENDIF

END SUBROUTINE SCALPRODSP

END PROGRAM TEST_ADJOINT
