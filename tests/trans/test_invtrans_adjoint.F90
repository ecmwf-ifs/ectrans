! (C) Copyright 2005- ECMWF.
! 
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.
!

PROGRAM TEST_INVTRANS_ADJOINT
USE PARKIND1  ,ONLY : JPIM     ,JPRB
USE MPL_MODULE  ,ONLY : MPL_INIT, MPL_END, MPL_BARRIER, MPL_MYRANK, MPL_NPROC
USE ABORT_TRANS_MOD  ! This is not really correct usage

IMPLICIT NONE

INTEGER(KIND=JPIM) :: NSMAX,NDGL,NPROC,NPRGPNS,NPRGPEW,NPRTRW,NPRTRV,NREP
INTEGER(KIND=JPIM) :: NOUT,MYPROC,NSPECG,NSPEC2G,NGPTOTG
INTEGER(KIND=JPIM) :: NFLEV,NFLEVG
INTEGER(KIND=JPIM) :: NSPEC2,NGPTOT,NPROMA,NGPBLKS,MYSETV,NUMP
INTEGER(KIND=JPIM) :: IVSET(1000)
INTEGER(KIND=JPIM) ,ALLOCATABLE :: NLOEN(:),ITOSP(:),ITOGP(:),MYMS(:),NASM0(:),IPRCIDS(:)
INTEGER(KIND=JPIM) :: JLEV,JREP,JROC, JA, JB

CHARACTER*6 CLNAME

REAL(KIND=JPRB) , ALLOCATABLE :: ZSPECX(:,:),ZSPECY(:,:)
REAL(KIND=JPRB) , ALLOCATABLE :: ZVORX(:,:),ZVORY(:,:)
REAL(KIND=JPRB) , ALLOCATABLE :: ZDIVX(:,:),ZDIVY(:,:)
REAL(KIND=JPRB) , ALLOCATABLE :: ZGX(:,:,:),ZGY(:,:,:)
REAL(KIND=JPRB) , ALLOCATABLE :: ZSPECYG(:,:),ZSPECXG(:,:)
REAL(KIND=JPRB) , ALLOCATABLE :: ZVORXG(:,:),ZVORYG(:,:)
REAL(KIND=JPRB) , ALLOCATABLE :: ZDIVXG(:,:),ZDIVYG(:,:)
REAL(KIND=JPRB) , ALLOCATABLE :: ZGXG(:,:),ZGYG(:,:)
REAL(KIND=JPRB) , ALLOCATABLE :: ZRANDSP(:),ZRANDGP(:)
REAL(KIND=JPRB) , ALLOCATABLE :: GW(:)
REAL(KIND=JPRB) :: ADJ_VALUE_1
REAL(KIND=JPRB) :: ADJ_VALUE_2, ADJ_VALUE_2_SPEC, ADJ_VALUE_2_VOR, ADJ_VALUE_2_DIV
REAL(KIND=JPRB) :: ZRELATIVE_ERROR
LOGICAL :: LMPOFF

#include "setup_trans0.h"
#include "setup_trans.h"
#include "trans_inq.h"
#include "dir_trans.h"
#include "inv_trans.h"
#include "dir_transad.h"
#include "inv_transad.h"
#include "gath_grid.h"
#include "dist_grid.h"
#include "gath_spec.h"
#include "dist_spec.h"

! ======== PARAMETERS WHICH MAY BE MODIFIED, ORIGINALLY COMING FROM NAMELIST ===========
NDGL = 32 ! number of parallels
NFLEVG = 9 ! number of field levels
NPROMA = 8 ! gridpoint block size
! ======================================================================================

#ifdef USE_MPI
CALL MPL_INIT
MYPROC = MPL_MYRANK()
NPROC = MPL_NPROC()
#else
MYPROC = 1
NPROC  = 1
#endif

! Compute E-W and V-W set sizes
DO JA = INT(SQRT(REAL(NPROC,JPRB))), NPROC
  JB = NPROC / JA
  IF (JA * JB == NPROC) THEN
    NPRGPNS = MAX(JA, JB)
    NPRGPEW = MIN(JA, JB)
    NPRTRW  = MAX(JA, JB)
    NPRTRV  = MIN(JA, JB)
  ENDIF
ENDDO

! ===== Set-up Trans =====
IF(NPROC /= NPRTRW*NPRTRV) THEN
  PRINT *,'NPRGPNS,NPRGPEW,NPRTRW,NPRTRV ',NPRGPNS,NPRGPEW,NPRTRW,NPRTRV
  CALL ABORT_TRANS('NPRGPNS*NPRGPEW /= NPRTRW*NPRTRV')
ENDIF
NSMAX = (2*NDGL-1)/3
NSPECG = (NSMAX+1)*(NSMAX+2)/2
NSPEC2G = NSPECG*2
IF(NPROC > 1 ) THEN
  NOUT = 20
  WRITE(CLNAME,'(A,I2.2)') 'OUT.',MYPROC
  OPEN(NOUT,FILE=CLNAME)
  LMPOFF = .FALSE.
ELSE
  LMPOFF = .TRUE.
  NOUT = 6
ENDIF
ALLOCATE(IPRCIDS(NPROC))
DO JROC=1,NPROC
  IPRCIDS(JROC) = JROC
ENDDO
WRITE(NOUT,*) ' NSMAX= ',NSMAX
WRITE(NOUT,*) ' NDGL=',NDGL
WRITE(NOUT,*) ' LMPOFF= ',LMPOFF

MYSETV = MOD(MYPROC-1,NPRTRV)+1
ALLOCATE(NLOEN(NDGL))
NLOEN(:) = 2*NDGL
CALL SETUP_TRANS0(KOUT=NOUT,KERR=0,KPRINTLEV=0,KMAX_RESOL=1,&
 & KPRGPNS=NPRGPNS,KPRGPEW=NPRGPEW,KPRTRW=NPRTRW,LDMPOFF=LMPOFF)
CALL SETUP_TRANS(KSMAX=NSMAX,KDGL=NDGL,KLOEN=NLOEN,LDSPLIT=.TRUE.)
CALL TRANS_INQ(KSPEC2=NSPEC2,KGPTOT=NGPTOT,KGPTOTG=NGPTOTG,KNUMP=NUMP)

ALLOCATE(MYMS(NUMP))
ALLOCATE(NASM0(0:NSMAX))
ALLOCATE(GW(NDGL))
CALL TRANS_INQ(KMYMS=MYMS,KASM0=NASM0,PGW=GW)
NGPBLKS = (NGPTOT-1)/NPROMA+1

WRITE(NOUT,*) ' NSPEC2=',NSPEC2
WRITE(NOUT,*) ' NGPTOT=',NGPTOT

NFLEV = 0
DO JLEV=1,NFLEVG
  IVSET(JLEV) = MOD(JLEV,NPRTRV)+1
  IF(IVSET(JLEV) == MYSETV) THEN
    NFLEV = NFLEV+1
  ENDIF
ENDDO
WRITE(NOUT,*)' NFLEV=',NFLEV
WRITE(NOUT,*) 'SETUP FINISHED'
FLUSH(NOUT)

ALLOCATE(ITOSP(NFLEVG)) ! ITO is used to distribute fields
ITOSP(:) = 1
ALLOCATE(ITOGP(3*NFLEVG)) ! ITO is used to distribute fields
ITOGP(:) = 1

! ===== Allocate and initialize spectral data =====

ALLOCATE(ZSPECXG(NFLEVG,NSPEC2G))
ALLOCATE(ZSPECYG(NFLEVG,NSPEC2G))
ALLOCATE(ZVORXG(NFLEVG,NSPEC2G))
ALLOCATE(ZVORYG(NFLEVG,NSPEC2G))
ALLOCATE(ZDIVXG(NFLEVG,NSPEC2G))
ALLOCATE(ZDIVYG(NFLEVG,NSPEC2G))

ALLOCATE(ZSPECX(NFLEV,NSPEC2))
ALLOCATE(ZSPECY(NFLEV,NSPEC2))
ALLOCATE(ZVORX(NFLEV,NSPEC2))
ALLOCATE(ZVORY(NFLEV,NSPEC2))
ALLOCATE(ZDIVX(NFLEV,NSPEC2))
ALLOCATE(ZDIVY(NFLEV,NSPEC2))

IF(MYPROC == 1) THEN
  CALL RANDOM_NUMBER(ZSPECXG)
  ZSPECXG(:,:) = (1.0_JPRB-2.0_JPRB*ZSPECXG(:,:))
  CALL RANDOM_NUMBER(ZSPECXG)
  ZVORXG(:,:) = (1.0_JPRB-2.0_JPRB*ZVORXG(:,:))
  CALL RANDOM_NUMBER(ZSPECXG)
  ZDIVXG(:,:) = (1.0_JPRB-2.0_JPRB*ZDIVXG(:,:))
ENDIF

CALL DIST_SPEC(PSPECG=ZSPECXG, KFDISTG=NFLEVG, KFROM=ITOSP, PSPEC=ZSPECX, &
             & KVSET=IVSET(1:NFLEVG))
CALL DIST_SPEC(PSPECG=ZVORXG, KFDISTG=NFLEVG, KFROM=ITOSP, PSPEC=ZVORX, &
             & KVSET=IVSET(1:NFLEVG))
CALL DIST_SPEC(PSPECG=ZDIVXG, KFDISTG=NFLEVG, KFROM=ITOSP, PSPEC=ZDIVX, &
             & KVSET=IVSET(1:NFLEVG))

! ===== Allocate and initialize gridpoint data =====

ALLOCATE(ZGXG(NGPTOTG,3*NFLEVG))
ALLOCATE(ZGYG(NGPTOTG,3*NFLEVG))
ALLOCATE(ZGX(NPROMA,3*NFLEVG,NGPBLKS))
ALLOCATE(ZGY(NPROMA,3*NFLEVG,NGPBLKS))

IF(MYPROC == 1) THEN
  CALL RANDOM_NUMBER(ZGXG)
  ZGXG(:,:) = (1.0_JPRB-2.0_JPRB*ZGXG(:,:))
ENDIF

CALL DIST_GRID(PGPG=ZGXG,KFDISTG=3*NFLEVG,KFROM=ITOGP,PGP=ZGX,KPROMA=NPROMA)

! ===== Compute invtrans and gather result on proc 1 =====
! i.e. invtrans(rspscalarx, rspvorx, rspdivx) = rgpy

CALL INV_TRANS(PSPSCALAR=ZSPECX,PSPVOR=ZVORX,PSPDIV=ZDIVX,PGP=ZGY,&
             & KPROMA=NPROMA,KVSETSC=IVSET(1:NFLEVG), KVSETUV=IVSET(1:NFLEVG))

! ===== Compute: adj_value2 = <invtrans(rspscalarx, rspvorx, rspdivx), rgpx> =====
! i.e. adj_value2 = <rgpy, rgpx>

ADJ_VALUE_1 = SCALPRODGP(ZGY,ZGX)

! ===== Compute adjoint invtrans and gather result on proc 1 =====
! i.e. invtrans_adj(rgpx) = (rspscalary, rspvory, rspdivy)

CALL INV_TRANSAD(PSPSCALAR=ZSPECY,PSPVOR=ZVORY,PSPDIV=ZDIVY,PGP=ZGX,&
               & KPROMA=NPROMA,KVSETSC=IVSET(1:NFLEVG),KVSETUV=IVSET(1:NFLEVG))

! ===== Compute: adj_value1 = <(rspscalarx, rspvorx, rspdivx), invtrans_adj(rgpx)> =====
! i.e. adj_value1 = <(rspscalary, rspvory, rspdivy), (rspscalarx, rspvorx, rspdivx)>

ADJ_VALUE_2 = SCALPRODSP(ZSPECX,ZSPECY)
ADJ_VALUE_2 = ADJ_VALUE_2 + SCALPRODSP(ZVORX,ZVORY)
ADJ_VALUE_2 = ADJ_VALUE_2 + SCALPRODSP(ZDIVX,ZDIVY)

! ===== Compare inner products =====
! i.e. <invtrans_adj(rgpx), (rspscalarx, rspvorx, rspdivx)> == <rgpx, invtrans(rspscalarx, rspvorx, rspdivx)>

ZRELATIVE_ERROR = ABS(ADJ_VALUE_1 - ADJ_VALUE_2)/ABS(ADJ_VALUE_1)

WRITE(NOUT, '(A,1E9.2)') '<Fx,y>  = ', ADJ_VALUE_1
WRITE(NOUT, '(A,1E9.2)') '<x,F*y> = ', ADJ_VALUE_2
WRITE(NOUT, '(A,1E9.2)') 'Relative error = ', ZRELATIVE_ERROR

! Abort if relative error is > 2000 * machine epsilon
! All tested compilers seem to be happy with a threshold of 2000, thought it is a bit arbitrary
IF (ZRELATIVE_ERROR > 2000.0*EPSILON(1.0_JPRB)) THEN
  WRITE(NOUT, '(A)') '*******************************'
  WRITE(NOUT, '(A)') 'Adjoint test failed'
  WRITE(NOUT, '(A)') 'Relative error greater than 2000 * machine epsilon'
  WRITE(NOUT, '(1E9.2,A3,1E9.2)') ZRELATIVE_ERROR, ' > ', 2000.0*EPSILON(1.0_JPRB)
  WRITE(NOUT, '(A)') '*******************************'
  FLUSH(NOUT)
  CALL ABORT_TRANS("Adjoint test failed")
ENDIF

#ifdef USE_MPI
CALL MPL_BARRIER()
CALL MPL_END
#endif

CONTAINS

FUNCTION SCALPRODGP(RGP1,RGP2) RESULT(RSC)

  ! Scalar product in spectral space
  REAL(KIND=JPRB) :: RGP1(NPROMA,3*NFLEVG,NGPBLKS),RGP2(NPROMA,3*NFLEVG,NGPBLKS)
  REAL(KIND=JPRB) :: RSC
  
  INTEGER(KIND=JPIM) :: JLEV,JKGLO,IEND,IBL,JROF
  REAL(KIND=JPRB) :: RGP(NPROMA,3*NFLEVG,NGPBLKS), RGPG(NGPTOTG,3*NFLEVG)
  
  RSC = 0.0_JPRB
  
  !$OMP PARALLEL DO SCHEDULE(STATIC,1) PRIVATE(JLEV,JKGLO,IEND,IBL,JROF)
  DO JLEV=1,3*NFLEVG
    DO JKGLO=1,NGPTOT,NPROMA
      IEND = MIN(NPROMA,NGPTOT-JKGLO+1)
      IBL  = (JKGLO-1)/NPROMA+1
      DO JROF=1,IEND
        RGP(JROF,JLEV,IBL) = RGP1(JROF,JLEV,IBL)*RGP2(JROF,JLEV,IBL)
      ENDDO
    ENDDO
  ENDDO
  !$OMP END PARALLEL DO
  
  CALL GATH_GRID(RGPG, NPROMA, 3*NFLEVG, ITOGP, PGP=RGP)
  
  IF(MYPROC == 1) THEN
    RSC = SUM(RGPG)
  ELSE
    RSC = 0.0_JPRB
  ENDIF
  
END FUNCTION SCALPRODGP

FUNCTION SCALPRODSP(PSP1,PSP2) RESULT(PSC)

  ! Scalar product in spectral space
  REAL(KIND=JPRB) :: PSP1(:,:),PSP2(:,:)
  REAL(KIND=JPRB) :: PSC

  INTEGER(KIND=JPIM) :: JMLOC,IM,JIR,JN,INM,JLEV
  REAL(KIND=JPRB) :: ZMFACT,ZSP(NFLEV,NSPEC2),ZSPG(NFLEVG,NSPEC2G)

  PSC = 0.0_JPRB
  ZSP(:,:) = 0.0_JPRB

  !$OMP PARALLEL DO SCHEDULE(STATIC,1) PRIVATE(JLEV,JMLOC,IM,ZMFACT,JIR,JN,INM)
  DO JLEV=1,NFLEV
    DO JMLOC=1,NUMP
      IM = MYMS(JMLOC)
      IF (IM .eq. 0) THEN
        ZMFACT=1.0_JPRB
      ELSE
        ZMFACT=2.0_JPRB
      ENDIF
      DO JIR=0,MIN(1,IM)
        DO JN=IM,NSMAX
          INM = NASM0(IM)+(JN-IM)*2+JIR
          ZSP(JLEV,INM) = PSP1(JLEV,INM)*PSP2(JLEV,INM)*ZMFACT
        ENDDO
      ENDDO
    ENDDO
  ENDDO
  !$OMP END PARALLEL DO

  CALL GATH_SPEC(PSPECG=ZSPG,KFGATHG=NFLEVG,KTO=ITOSP,PSPEC=ZSP,&
              & KVSET=IVSET(1:NFLEVG))

  IF(MYPROC == 1) THEN
    PSC = SUM(ZSPG)
  ELSE
    PSC = 0.0_JPRB
  ENDIF

END FUNCTION SCALPRODSP

END PROGRAM TEST_INVTRANS_ADJOINT
